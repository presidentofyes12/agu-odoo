Error when installing any Odoo module:

RPC_ERROR
Odoo Server Error
Traceback (most recent call last):
  File "/opt/odoo/odoo/odoo/tools/convert.py", line 698, in _tag_root
    f(rec)
  File "/opt/odoo/odoo/odoo/tools/convert.py", line 599, in _tag_record
    record = model._load_records([data], self.mode == 'update')
  File "/opt/odoo/odoo/odoo/models.py", line 4394, in _load_records
    data['record']._load_records_write(data['values'])
  File "/opt/odoo/odoo/odoo/models.py", line 4325, in _load_records_write
    self.write(values)
  File "/opt/odoo/odoo/addons/mail/models/mail_channel.py", line 263, in write
    self._subscribe_users_automatically()
  File "/opt/odoo/odoo/addons/mail/models/mail_channel.py", line 291, in _subscribe_users_automatically
    self.env['mail.channel.member'].sudo().create(to_create)
  File "<decorator-gen-137>", line 2, in create
  File "/opt/odoo/odoo/odoo/api.py", line 415, in _model_create_multi
    return create(self, arg)
  File "/opt/odoo/odoo/addons/mail/models/mail_channel_member.py", line 88, in create
    return super().create(vals_list)
  File "<decorator-gen-66>", line 2, in create
  File "/opt/odoo/odoo/odoo/api.py", line 415, in _model_create_multi
    return create(self, arg)
  File "/opt/odoo/odoo/odoo/addons/base/models/ir_fields.py", line 670, in create
    recs = super().create(vals_list)
  File "<decorator-gen-15>", line 2, in create
  File "/opt/odoo/odoo/odoo/api.py", line 415, in _model_create_multi
    return create(self, arg)
  File "/opt/odoo/odoo/odoo/models.py", line 3984, in create
    records = self._create(data_list)
  File "/opt/odoo/odoo/odoo/models.py", line 4165, in _create
    cr.execute(
  File "/opt/odoo/odoo/odoo/sql_db.py", line 321, in execute
    res = self._obj.execute(query, params)
psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "mail_channel_member_partner_unique"
DETAIL:  Key (channel_id, partner_id)=(1, 2) already exists.


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/opt/odoo/odoo/odoo/http.py", line 1652, in _serve_db
    return service_model.retrying(self._serve_ir_http, self.env)
  File "/opt/odoo/odoo/odoo/service/model.py", line 133, in retrying
    result = func()
  File "/opt/odoo/odoo/odoo/http.py", line 1679, in _serve_ir_http
    response = self.dispatcher.dispatch(rule.endpoint, args)
  File "/opt/odoo/odoo/odoo/http.py", line 1883, in dispatch
    result = self.request.registry['ir.http']._dispatch(endpoint)
  File "/opt/odoo/odoo/odoo/addons/base/models/ir_http.py", line 154, in _dispatch
    result = endpoint(**request.params)
  File "/opt/odoo/odoo/odoo/http.py", line 734, in route_wrapper
    result = endpoint(self, *args, **params_ok)
  File "/opt/odoo/odoo/addons/web/controllers/dataset.py", line 46, in call_button
    action = self._call_kw(model, method, args, kwargs)
  File "/opt/odoo/odoo/addons/web/controllers/dataset.py", line 33, in _call_kw
    return call_kw(request.env[model], method, args, kwargs)
  File "/opt/odoo/odoo/odoo/api.py", line 468, in call_kw
    result = _call_kw_multi(method, model, args, kwargs)
  File "/opt/odoo/odoo/odoo/api.py", line 453, in _call_kw_multi
    result = method(recs, *args, **kwargs)
  File "<decorator-gen-72>", line 2, in button_immediate_install
  File "/opt/odoo/odoo/odoo/addons/base/models/ir_module.py", line 74, in check_and_log
    return method(self, *args, **kwargs)
  File "/opt/odoo/odoo/odoo/addons/base/models/ir_module.py", line 478, in button_immediate_install
    return self._button_immediate_function(self.env.registry[self._name].button_install)
  File "/opt/odoo/odoo/odoo/addons/base/models/ir_module.py", line 602, in _button_immediate_function
    registry = modules.registry.Registry.new(self._cr.dbname, update_module=True)
  File "<decorator-gen-16>", line 2, in new
  File "/opt/odoo/odoo/odoo/tools/func.py", line 87, in locked
    return func(inst, *args, **kwargs)
  File "/opt/odoo/odoo/odoo/modules/registry.py", line 91, in new
    odoo.modules.load_modules(registry, force_demo, status, update_module)
  File "/opt/odoo/odoo/odoo/modules/loading.py", line 488, in load_modules
    processed_modules += load_marked_modules(cr, graph,
  File "/opt/odoo/odoo/odoo/modules/loading.py", line 372, in load_marked_modules
    loaded, processed = load_module_graph(
  File "/opt/odoo/odoo/odoo/modules/loading.py", line 231, in load_module_graph
    load_data(cr, idref, mode, kind='data', package=package)
  File "/opt/odoo/odoo/odoo/modules/loading.py", line 71, in load_data
    tools.convert_file(cr, package.name, filename, idref, mode, noupdate, kind)
  File "/opt/odoo/odoo/odoo/tools/convert.py", line 763, in convert_file
    convert_xml_import(cr, module, fp, idref, mode, noupdate)
  File "/opt/odoo/odoo/odoo/tools/convert.py", line 829, in convert_xml_import
    obj.parse(doc.getroot())
  File "/opt/odoo/odoo/odoo/tools/convert.py", line 749, in parse
    self._tag_root(de)
  File "/opt/odoo/odoo/odoo/tools/convert.py", line 698, in _tag_root
    f(rec)
  File "/opt/odoo/odoo/odoo/tools/convert.py", line 711, in _tag_root
    raise ParseError('while parsing %s:%s, somewhere inside\n%s' % (
odoo.tools.convert.ParseError: while parsing /opt/odoo/odoo/addons/mail/data/mail_channel_data.xml:28, somewhere inside
<record model="mail.channel" id="mail.channel_all_employees">
            <field name="group_ids" eval="[Command.link(ref('base.group_user'))]"/>
        </record>

The above server error caused the following client error:
RPC_ERROR: Odoo Server Error
    RPCError@http://localhost:8069/web/assets/22-2f3bc67/web.assets_backend.min.js:993:274
    makeErrorFromResponse@http://localhost:8069/web/assets/22-2f3bc67/web.assets_backend.min.js:997:163
    jsonrpc/promise</<@http://localhost:8069/web/assets/22-2f3bc67/web.assets_backend.min.js:1005:34
    


db_init.sql:

-- Create the ir_config_parameter table if it doesn't exist
CREATE TABLE IF NOT EXISTS ir_config_parameter (
    id SERIAL PRIMARY KEY,
    key VARCHAR(255) UNIQUE NOT NULL,
    value TEXT
);

-- Create relay table if it doesn't exist
CREATE TABLE IF NOT EXISTS nostr_relay_urls (
    id SERIAL PRIMARY KEY,
    url VARCHAR(255) NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add configuration parameters
INSERT INTO ir_config_parameter (key, value)
VALUES 
    ('auth_provider', 'nostr'),
    ('nostr_authentication.enabled', 'true'),
    ('auth_nostr.enabled', 'true'),
    ('nostr.relay_urls', 'wss://nostr-pub.wellorder.net')
ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value;

-- Add relay URLs
INSERT INTO nostr_relay_urls (url, is_active)
VALUES 
    ('wss://nostr-pub.wellorder.net', true)
ON CONFLICT (url) DO UPDATE SET is_active = true;

docker-compose.yml:

version: '3'
services:
  postgres:
    image: postgres:14
    environment:
      - POSTGRES_PASSWORD=odoo
      - POSTGRES_USER=postgres
      - POSTGRES_DB=postgres
      - PGDATA=/var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgresql.conf:/etc/postgresql/postgresql.conf
    networks:
      - odoo_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: postgres -c "config_file=/etc/postgresql/postgresql.conf"

  odoo:
    build: .
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "8069:8069"
      - "8072:8072"
    volumes:
      - ./queue:/opt/odoo/queue
      - ./odoo.conf:/etc/odoo/odoo.conf:ro
      - ./odoo_custom_addons:/opt/odoo/custom_addons
      - odoo_data:/opt/odoo/.local/share/Odoo
      - ./logs:/var/log/odoo
      - ivcs_repos:/opt/ivcs_repos
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=odoo
      - DB_PASSWORD=odoo
      - DB_NAME=odoodb
      - PGHOST=postgres
      - PGPORT=5432
      - PGUSER=odoo
      - PGPASSWORD=odoo
      - WAIT_FOR_DB=true
      - NOSTR_RELAY_URLS=wss://nostr-pub.wellorder.net
      - PYTHONUNBUFFERED=1
      - PYTHONDONTWRITEBYTECODE=1
      - LOG_LEVEL=debug
    networks:
      - odoo_network
    command: >
      bash -c "
        /opt/odoo/wait-for-psql.sh &&
        sleep 5 &&
        python3 -u /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf --dev all
      "

networks:
  odoo_network:
    driver: bridge

volumes:
  postgres_data:
  odoo_data:
  odoo_logs:
  ivcs_repos:
  
docker-entrypoint.sh:

#!/bin/bash
set -e

# Function to check if postgres is ready
postgres_ready() {
    local max_attempts=30
    local attempt=1
    while [ $attempt -le $max_attempts ]; do
        PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres -c "\q" > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            return 0
        fi
        sleep 2
        attempt=$((attempt + 1))
    done
    return 1
}

# Wait for PostgreSQL
echo "Waiting for PostgreSQL..."
until postgres_ready; do
  sleep 1
done
echo "PostgreSQL is ready!"

# Create database if it doesn't exist
PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
    PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres -c "CREATE DATABASE $DB_NAME OWNER $DB_USER;"

# Ensure ir_config_parameter table exists
echo "Configuring database tables..."
PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME << EOF
-- Create tables if they don't exist
CREATE TABLE IF NOT EXISTS ir_config_parameter (
    id SERIAL PRIMARY KEY,
    key VARCHAR(255) UNIQUE NOT NULL,
    value TEXT
);

CREATE TABLE IF NOT EXISTS nostr_relay_urls (
    id SERIAL PRIMARY KEY,
    url VARCHAR(255) NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add configuration parameters
INSERT INTO ir_config_parameter (key, value)
VALUES 
    ('auth_provider', 'nostr'),
    ('nostr_authentication.enabled', 'true'),
    ('auth_nostr.enabled', 'true'),
    ('nostr.relay_urls', 'wss://nostr-pub.wellorder.net')
ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value;

-- Add relay URLs
INSERT INTO nostr_relay_urls (url, is_active)
VALUES 
    ('wss://nostr-pub.wellorder.net', true)
ON CONFLICT (url) DO UPDATE SET is_active = true;
EOF

# Initialize database if needed
python3 /opt/odoo/odoo/odoo-bin -c /etc/odoo/odoo.conf -d $DB_NAME -i base --stop-after-init || true

# run pre-update checks
if [ -f /opt/odoo/check_nostr_bridge.sh ]; then
    /opt/odoo/check_nostr_bridge.sh
fi
sleep 2

# Start Odoo
exec "$@"

Dockerfile:

FROM ubuntu:22.04
ENV ODOO_VERSION=16.0 \
    OPENEDUCAT_VERSION=16.0 \
    DEBIAN_FRONTEND=noninteractive \
    PATH=$PATH:/usr/local/bin

# Install dependencies
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    python3-dev \
    python3-venv \
    postgresql-client \
    nodejs \
    npm \
    git \
    wget \
    libxml2-dev \
    libxslt1-dev \
    libjpeg-dev \
    libfreetype6-dev \
    libpq-dev \
    build-essential \
    libldap2-dev \
    libsasl2-dev \
    libssl-dev \
    libffi-dev \
    iputils-ping \
    curl \
    netcat \
    sudo \
    && rm -rf /var/lib/apt/lists/*

# Create Odoo user and add to sudo group
RUN useradd -m -d /opt/odoo -U -r -s /bin/bash odoo && \
    usermod -aG sudo odoo && \
    echo "odoo ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# Create necessary directories with correct permissions
RUN mkdir -p /var/run/postgresql && \
    chmod 777 /var/run/postgresql && \
    mkdir -p /etc/odoo \
    /opt/ivcs_repos \
    /var/lib/odoo \
    /var/log/odoo \
    /opt/odoo/.local/share/Odoo/filestore \
    /opt/odoo/.local/share/Odoo/sessions \
    /run/odoo && \
    chown -R odoo:odoo \
    /opt/odoo \
    /etc/odoo \
    /opt/ivcs_repos \
    /var/lib/odoo \
    /var/log/odoo \
    /run/odoo \
    /var/run/postgresql

# Clone Odoo and OpenEduCat as odoo user
USER odoo
RUN git clone https://github.com/odoo/odoo.git --depth 1 --branch ${ODOO_VERSION} /opt/odoo/odoo && \
    git clone https://github.com/openeducat/openeducat_erp.git --depth 1 --branch ${OPENEDUCAT_VERSION} /opt/odoo/openeducat

# Add passlib to the pip install command
RUN pip3 install --upgrade pip && \
    pip3 install --no-cache-dir -r /opt/odoo/odoo/requirements.txt && \
    pip3 install cryptography pyopenssl==22.1.0 psycopg2-binary bs4 BeautifulSoup4 gitpython bech32 websocket-client websockets && \
    pip3 install nostr && \
    pip3 install python-gitlab && \
    pip3 install passlib && \
    pip3 install python-ldap lxml pillow psutil html2text pypdf2 reportlab requests \
    num2words xlwt phonenumbers pytz polib unidecode

# Copy OpenEduCat addons
RUN cp -r /opt/odoo/openeducat/* /opt/odoo/odoo/addons/

# Copy custom files
COPY --chown=odoo:odoo ./nostr_auth.py /opt/odoo/
COPY --chown=odoo:odoo ./custom_odoo_server.py /opt/odoo/
COPY --chown=odoo:odoo ./odoo_custom_addons /opt/odoo/custom_addons
COPY --chown=odoo:odoo ./check_nostr_bridge.sh /opt/odoo/
COPY --chown=odoo:odoo ./docker-entrypoint.sh /opt/odoo/

# Create wait-for-psql script
RUN echo '#!/bin/bash\n\
while ! PGPASSWORD=$DB_PASSWORD psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -c "\q" 2>/dev/null; do\n\
    echo "Postgres is unavailable - sleeping"\n\
    sleep 1\n\
done\n\
echo "PostgreSQL is ready!"' > /opt/odoo/wait-for-psql.sh

# Set execute permissions
RUN chmod +x \
    /opt/odoo/check_nostr_bridge.sh \
    /opt/odoo/custom_odoo_server.py \
    /opt/odoo/wait-for-psql.sh \
    /opt/odoo/docker-entrypoint.sh

# Patch OpenSSL
USER root
RUN echo "from OpenSSL import crypto" > /tmp/patch_openssl.py && \
    echo "if not hasattr(crypto, 'X509_V_FLAG_EXPLICIT_POLICY'):" >> /tmp/patch_openssl.py && \
    echo "    crypto.X509_V_FLAG_EXPLICIT_POLICY = 0x8000" >> /tmp/patch_openssl.py && \
    echo "exec(open('/tmp/patch_openssl.py').read())" >> /opt/odoo/odoo/odoo/addons/base/models/ir_mail_server.py

USER odoo
WORKDIR /opt/odoo

VOLUME ["/var/lib/odoo", "/opt/odoo/odoo/addons", "/opt/odoo/custom_addons"]
EXPOSE 8069 8072

ENTRYPOINT ["/opt/odoo/docker-entrypoint.sh"]
CMD ["python3", "/opt/odoo/odoo/odoo-bin", "-c", "/etc/odoo/odoo.conf"]

odoo.conf:

[options]
admin_passwd = admin
db_host = postgres
db_port = 5432
db_user = odoo
db_password = odoo
db_name = odoodb
addons_path = /opt/odoo/odoo/addons,/opt/odoo/odoo/odoo/addons,/opt/odoo/custom_addons
http_port = 8069
logfile = /var/log/odoo/odoo-server.log
log_level = debug
log_handler = odoo.modules:DEBUG,odoo.addons.base:DEBUG,odoo.addons.web:DEBUG,odoo.addons.mail:DEBUG
workers = 0
max_cron_threads = 1
proxy_mode = True
without_demo = True
dev_mode = False

odoo_setup.sh:

#!/bin/bash
set -e

# Set environment variables with Nostr credentials
export NOSTR_PUBKEY="npub1qpr5ntstknpz6z9ar996c54m7uzs6mn0pf3yx537ymy0edjl4taqrx0z0q"
export NOSTR_PRIVKEY="nsec1lh24ln2m93xf9a7a4q3a32s5vu9kaj6n9je7uu00yhtgtea9wq2sxr3jxs"
export NOSTR_RELAYS="wss://nostr-pub.wellorder.net"

# Function to log messages
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
}

# Function to install a module with proper error handling
install_module() {
    local module=$1
    log "Installing module: $module"
    sudo docker exec -i odoo-nostr-project_odoo_1 /opt/odoo/odoo/odoo-bin \
        -c /etc/odoo/odoo.conf \
        -d odoodb \
        -i $module \
        --stop-after-init \
        --no-http \
        --log-level=debug 2>&1 | tee /tmp/odoo_install.log || {
        log "Module installation failed: $module"
        cat /tmp/odoo_install.log
        return 1
    }
}

# Function to wait for PostgreSQL
wait_for_postgres() {
    local retries=30
    local count=0
    until sudo docker exec odoo-nostr-project_postgres_1 pg_isready -h localhost -U postgres || [ $count -eq $retries ]; do
        log "Waiting for PostgreSQL to be ready... ($count/$retries)"
        sleep 2
        count=$((count + 1))
    done
    if [ $count -eq $retries ]; then
        log "Error: PostgreSQL did not become ready in time"
        exit 1
    fi
}

# Function to wait for database setup
wait_for_database() {
    local retries=30
    local count=0
    until sudo docker exec odoo-nostr-project_postgres_1 psql -U postgres -d odoodb -c "\q" 2>/dev/null || [ $count -eq $retries ]; do
        log "Waiting for database 'odoodb' to be ready... ($count/$retries)"
        sleep 2
        count=$((count + 1))
    done
    if [ $count -eq $retries ]; then
        log "Error: Database 'odoodb' did not become ready in time"
        exit 1
    fi
}

# Function to setup database
setup_database() {
    log "Setting up PostgreSQL database..."
    sudo docker exec -i odoo-nostr-project_postgres_1 psql -U postgres << EOF
-- Create odoo user with password
DROP ROLE IF EXISTS odoo;
CREATE ROLE odoo WITH LOGIN SUPERUSER PASSWORD 'odoo';

-- Create database if it doesn't exist
DROP DATABASE IF EXISTS odoodb;
CREATE DATABASE odoodb OWNER odoo;

-- Connect to the database
\c odoodb

-- Create extensions
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Set session parameters to avoid serialization failures
SET SESSION synchronous_commit = 'off';
SET default_transaction_isolation = 'read committed';
EOF
}

# Function to wait for Odoo
wait_for_odoo() {
    local retries=30
    local count=0
    until curl -s http://localhost:8069 >/dev/null || [ $count -eq $retries ]; do
        log "Waiting for Odoo to start... ($count/$retries)"
        sleep 2
        count=$((count + 1))
    done
    if [ $count -eq $retries ]; then
        log "Error: Odoo did not start in time"
        exit 1
    fi
}

# Function to check database state
check_db_state() {
    local checkpoint=$1
    log "Database state check at: $checkpoint"
    sudo docker exec -i odoo-nostr-project_postgres_1 psql -U odoo -d odoodb << 'EOF'
    -- Check table relationships
    SELECT 
        tc.table_schema, 
        tc.constraint_name, 
        tc.table_name, 
        kcu.column_name, 
        ccu.table_name AS foreign_table_name,
        ccu.column_name AS foreign_column_name 
    FROM 
        information_schema.table_constraints AS tc 
        JOIN information_schema.key_column_usage AS kcu
          ON tc.constraint_name = kcu.constraint_name
        JOIN information_schema.constraint_column_usage AS ccu
          ON ccu.constraint_name = tc.constraint_name
    WHERE tc.constraint_type = 'FOREIGN KEY';

    -- Check current state of users and partners
    SELECT id, login, partner_id FROM res_users;
    SELECT id, name FROM res_partner;
    
    -- Show detailed table structure
    \d+ res_users;
    \d+ res_partner;
EOF

    # Truncate Odoo logs to last 100 lines
    log "Last 100 lines of Odoo logs at: $checkpoint"
    sudo docker exec -i odoo-nostr-project_odoo_1 tail -n 100 /var/log/odoo/odoo-server.log
}

# Cleanup
log "Cleaning up existing containers..."
sudo docker-compose down -v
sudo docker system prune -a --volumes -f

# Create required directories and set permissions
log "Creating required directories..."
sudo mkdir -p /var/run/postgresql logs /var/log/odoo
sudo chmod -R 777 /var/run/postgresql logs /var/log/odoo

# Configure Odoo
log "Configuring Odoo..."
cat > odoo.conf << EOL
[options]
admin_passwd = admin
db_host = postgres
db_port = 5432
db_user = odoo
db_password = odoo
db_name = odoodb
addons_path = /opt/odoo/odoo/addons,/opt/odoo/odoo/odoo/addons,/opt/odoo/custom_addons
http_port = 8069
logfile = /var/log/odoo/odoo-server.log
log_level = debug
log_handler = [':DEBUG']
workers = 0
max_cron_threads = 1
proxy_mode = True
without_demo = True
dev_mode = False
EOL

# Start PostgreSQL
log "Starting PostgreSQL..."
sudo docker-compose up -d postgres
wait_for_postgres

# Setup database
setup_database
wait_for_database

# Start Odoo
log "Starting Odoo..."
sudo docker-compose up -d odoo
wait_for_odoo

# Add before base initialization
check_db_state "before-base-init"

# Initialize base database
log "Initializing base module..."
install_module "base"

sleep 10

# Add after base initialization
check_db_state "after-base-init"

# Setup mail channel prerequisites with proper order of operations
log "Setting up mail channel prerequisites..."
sudo docker exec -i odoo-nostr-project_postgres_1 psql -U odoo -d odoodb << 'EOF'
DO $$
BEGIN
    -- First delete from res_users since it references res_partner
    DELETE FROM res_users WHERE partner_id = 2;
    -- Then we can safely delete from res_partner
    DELETE FROM res_partner WHERE id = 2;
    
    -- Reset sequences
    ALTER SEQUENCE res_users_id_seq RESTART WITH 2;
    ALTER SEQUENCE res_partner_id_seq RESTART WITH 2;
    
    -- Clean up mail-related tables
    DROP TABLE IF EXISTS mail_message CASCADE;
    DROP TABLE IF EXISTS mail_mail CASCADE;
    DROP TABLE IF EXISTS mail_channel CASCADE;
    DROP TABLE IF EXISTS mail_channel_partner CASCADE;
    DROP TABLE IF EXISTS mail_followers CASCADE;
    DROP TABLE IF EXISTS mail_thread CASCADE;
END $$;
EOF

sleep 5

# Set up Nostr schema
log "Setting up Nostr schema..."
sudo docker exec -i odoo-nostr-project_postgres_1 psql -U odoo -d odoodb << 'EOF'
BEGIN;
ALTER TABLE res_users ADD COLUMN IF NOT EXISTS nostr_public_key VARCHAR;
ALTER TABLE res_users ADD COLUMN IF NOT EXISTS nostr_private_key VARCHAR;
ALTER TABLE res_users ADD COLUMN IF NOT EXISTS password_crypt VARCHAR;

DROP INDEX IF EXISTS nostr_public_key_unique;
CREATE UNIQUE INDEX nostr_public_key_unique ON res_users (nostr_public_key) WHERE nostr_public_key IS NOT NULL;

CREATE TABLE IF NOT EXISTS nostr_relay (
    id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL,
    url VARCHAR NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS res_users_nostr_relay_rel (
    user_id INTEGER REFERENCES res_users(id) ON DELETE CASCADE,
    relay_id INTEGER REFERENCES nostr_relay(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, relay_id)
);
COMMIT;
EOF

# Generate and set admin password
log "Setting up admin user..."
HASHED_PASSWORD=$(sudo docker exec odoo-nostr-project_odoo_1 python3 -c "
from passlib.context import CryptContext;
ctx = CryptContext(schemes=['pbkdf2_sha512']);
print(ctx.hash('${NOSTR_PRIVKEY}'))")

sudo docker exec -i odoo-nostr-project_postgres_1 psql -U odoo -d odoodb << EOF
BEGIN;
UPDATE res_users 
SET login = '${NOSTR_PUBKEY}',
    password = '${HASHED_PASSWORD}',
    nostr_public_key = '${NOSTR_PUBKEY}',
    nostr_private_key = '${NOSTR_PRIVKEY}',
    active = true
WHERE id = 1;

UPDATE res_partner 
SET name = 'Nostr Admin', 
    email = '${NOSTR_PUBKEY}' 
WHERE id = 1;

INSERT INTO nostr_relay (name, url, is_active)
VALUES ('Default Relay', '${NOSTR_RELAYS}', true)
ON CONFLICT (url) DO NOTHING;

INSERT INTO res_users_nostr_relay_rel (user_id, relay_id)
SELECT 1, id FROM nostr_relay WHERE url = '${NOSTR_RELAYS}'
ON CONFLICT DO NOTHING;
COMMIT;
EOF

# Add before mail module installation
check_db_state "before-mail-install"

# Install dependencies first
log "Installing mail module dependencies..."
install_module "web,bus"

sleep 5

# Clean up any existing mail channel data
log "Cleaning up before mail module installation..."
sudo docker exec -i odoo-nostr-project_postgres_1 psql -U odoo -d odoodb << 'EOF'
DO $$
BEGIN
    -- Drop any existing mail-related tables if they exist
    DROP TABLE IF EXISTS mail_channel_member CASCADE;
    DROP TABLE IF EXISTS mail_channel CASCADE;
    DROP TABLE IF EXISTS mail_channel_partner CASCADE;
    
    -- Reset sequences if they exist
    PERFORM setval('mail_channel_id_seq', 1, false) WHERE EXISTS (SELECT 1 FROM pg_sequences WHERE sequencename = 'mail_channel_id_seq');
    PERFORM setval('mail_channel_member_id_seq', 1, false) WHERE EXISTS (SELECT 1 FROM pg_sequences WHERE sequencename = 'mail_channel_member_id_seq');
    PERFORM setval('mail_channel_partner_id_seq', 1, false) WHERE EXISTS (SELECT 1 FROM pg_sequences WHERE sequencename = 'mail_channel_partner_id_seq');
END $$;
EOF

# Install mail module
log "Installing mail module..."
install_module "mail"

sleep 10

# Add after mail module installation
check_db_state "after-mail-install"

# Verify setup
log "Verifying setup..."
sudo docker exec -i odoo-nostr-project_postgres_1 psql -U odoo -d odoodb << 'EOF'
\d res_users
SELECT login, active FROM res_users WHERE id = 1;
SELECT * FROM nostr_relay;
SELECT * FROM res_users_nostr_relay_rel;
EOF

log "Setup complete!"
log "Admin username (Nostr public key): $NOSTR_PUBKEY"
log "Admin password (Nostr private key): $NOSTR_PRIVKEY"
log "You can now access Odoo at http://localhost:8069"



Main Odoo module files (should not be changed directly):

odoo@5cfc0603deef:~/odoo/addons/mail$ find ./wizard -type f -exec echo "=== {} ===" \; -exec cat {} \;
=== ./wizard/mail_compose_message.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import ast
import base64
import re

from odoo import _, api, fields, models, tools, Command
from odoo.exceptions import UserError
from odoo.osv import expression


def _reopen(self, res_id, model, context=None):
    # save original model in context, because selecting the list of available
    # templates requires a model in context
    context = dict(context or {}, default_model=model)
    return {'name': _('Compose Email'),
            'type': 'ir.actions.act_window',
            'view_mode': 'form',
            'res_id': res_id,
            'res_model': self._name,
            'target': 'new',
            'context': context,
            }


class MailComposer(models.TransientModel):
    """ Generic message composition wizard. You may inherit from this wizard
        at model and view levels to provide specific features.

        The behavior of the wizard depends on the composition_mode field:
        - 'comment': post on a record. The wizard is pre-populated via ``get_record_data``
        - 'mass_mail': wizard in mass mailing mode where the mail details can
            contain template placeholders that will be merged with actual data
            before being sent to each recipient.
    """
    _name = 'mail.compose.message'
    _inherit = 'mail.composer.mixin'
    _description = 'Email composition wizard'
    _log_access = True
    _batch_size = 500

    @api.model
    def default_get(self, fields):
        """ Handle composition mode. Some details about context keys:
            - comment: default mode, model and ID of a record the user comments
                - default_model or active_model
                - default_res_id or active_id
            - mass_mail: model and IDs of records the user mass-mails
                - active_ids: record IDs
                - default_model or active_model
        """
        # backward compatibility of context before addition of
        # email_layout_xmlid field: to remove in 15.1+
        if self._context.get('custom_layout') and 'default_email_layout_xmlid' not in self._context:
            self = self.with_context(default_email_layout_xmlid=self._context['custom_layout'])

        result = super(MailComposer, self).default_get(fields)

        # author
        missing_author = 'author_id' in fields and 'author_id' not in result
        missing_email_from = 'email_from' in fields and 'email_from' not in result
        if missing_author or missing_email_from:
            author_id, email_from = self.env['mail.thread']._message_compute_author(result.get('author_id'), result.get('email_from'), raise_on_email=False)
            if missing_email_from:
                result['email_from'] = email_from
            if missing_author:
                result['author_id'] = author_id

        if 'model' in fields and 'model' not in result:
            result['model'] = self._context.get('active_model')
        if 'res_id' in fields and 'res_id' not in result:
            result['res_id'] = self._context.get('active_id')
        if 'reply_to_mode' in fields and 'reply_to_mode' not in result and result.get('model'):
            # doesn't support threading
            if result['model'] not in self.env or not hasattr(self.env[result['model']], 'message_post'):
                result['reply_to_mode'] = 'new'

        if 'active_domain' in self._context:  # not context.get() because we want to keep global [] domains
            result['active_domain'] = '%s' % self._context.get('active_domain')
        if result.get('composition_mode') == 'comment' and (set(fields) & set(['model', 'res_id', 'partner_ids', 'record_name', 'subject'])):
            result.update(self.get_record_data(result))

        # when being in new mode, create_uid is not granted -> ACLs issue may arise
        if 'create_uid' in fields and 'create_uid' not in result:
            result['create_uid'] = self.env.uid

        filtered_result = dict((fname, result[fname]) for fname in result if fname in fields)
        return filtered_result

    def _partner_ids_domain(self):
        return expression.OR([
            [('type', '!=', 'private')],
            [('id', 'in', self.env.context.get('default_partner_ids', []))],
        ])

    # content
    subject = fields.Char('Subject', compute=False)
    body = fields.Html('Contents', render_engine='qweb', compute=False, default='', sanitize_style=True)
    parent_id = fields.Many2one(
        'mail.message', 'Parent Message', ondelete='set null')
    template_id = fields.Many2one('mail.template', 'Use template', domain="[('model', '=', model)]")
    attachment_ids = fields.Many2many(
        'ir.attachment', 'mail_compose_message_ir_attachments_rel',
        'wizard_id', 'attachment_id', 'Attachments')
    email_layout_xmlid = fields.Char('Email Notification Layout', copy=False)
    email_add_signature = fields.Boolean(default=True)
    # origin
    email_from = fields.Char('From', help="Email address of the sender. This field is set when no matching partner is found and replaces the author_id field in the chatter.")
    author_id = fields.Many2one(
        'res.partner', 'Author',
        help="Author of the message. If not set, email_from may hold an email address that did not match any partner.")
    # composition
    composition_mode = fields.Selection(selection=[
        ('comment', 'Post on a document'),
        ('mass_mail', 'Email Mass Mailing'),
        ('mass_post', 'Post on Multiple Documents')], string='Composition mode', default='comment')
    model = fields.Char('Related Document Model')
    res_id = fields.Integer('Related Document ID')
    record_name = fields.Char('Message Record Name')
    use_active_domain = fields.Boolean('Use active domain')
    active_domain = fields.Text('Active domain', readonly=True)
    # characteristics
    message_type = fields.Selection([
        ('auto_comment', 'Automated Targeted Notification'),
        ('comment', 'Comment'),
        ('notification', 'System notification')],
        'Type', required=True, default='comment',
        help="Message type: email for email message, notification for system "
             "message, comment for other messages such as user replies")
    is_log = fields.Boolean('Log as Internal Note')
    subtype_id = fields.Many2one(
        'mail.message.subtype', 'Subtype', ondelete='set null',
        default=lambda self: self.env['ir.model.data']._xmlid_to_res_id('mail.mt_comment'))
    notify = fields.Boolean('Notify followers', help='Notify followers of the document (mass post only)')
    mail_activity_type_id = fields.Many2one('mail.activity.type', 'Mail Activity Type', ondelete='set null')
    # destination
    reply_to = fields.Char('Reply To', help='Reply email address. Setting the reply_to bypasses the automatic thread creation.')
    reply_to_force_new = fields.Boolean(
        string='Considers answers as new thread',
        help='Manage answers as new incoming emails instead of replies going to the same thread.')
    reply_to_mode = fields.Selection([
        ('update', 'Store email and replies in the chatter of each record'),
        ('new', 'Collect replies on a specific email address')],
        string='Replies', compute='_compute_reply_to_mode', inverse='_inverse_reply_to_mode',
        help="Original Discussion: Answers go in the original document discussion thread. \n Another Email Address: Answers go to the email address mentioned in the tracking message-id instead of original document discussion thread. \n This has an impact on the generated message-id.")
    # recipients
    partner_ids = fields.Many2many(
        'res.partner', 'mail_compose_message_res_partner_rel',
        'wizard_id', 'partner_id', 'Additional Contacts',
        domain=_partner_ids_domain)
    # sending
    auto_delete = fields.Boolean('Delete Emails',
        help='This option permanently removes any track of email after it\'s been sent, including from the Technical menu in the Settings, in order to preserve storage space of your Odoo database.')
    auto_delete_message = fields.Boolean('Delete Message Copy', help='Do not keep a copy of the email in the document communication history (mass mailing only)')
    mail_server_id = fields.Many2one('ir.mail_server', 'Outgoing mail server')

    @api.depends('reply_to_force_new')
    def _compute_reply_to_mode(self):
        for composer in self:
            composer.reply_to_mode = 'new' if composer.reply_to_force_new else 'update'

    def _inverse_reply_to_mode(self):
        for composer in self:
            composer.reply_to_force_new = composer.reply_to_mode == 'new'

    # Overrides of mail.render.mixin
    @api.depends('model')
    def _compute_render_model(self):
        for composer in self:
            composer.render_model = composer.model

    # Onchanges

    @api.onchange('template_id')
    def _onchange_template_id_wrapper(self):
        self.ensure_one()
        values = self._onchange_template_id(self.template_id.id, self.composition_mode, self.model, self.res_id)['value']
        for fname, value in values.items():
            setattr(self, fname, value)

    def _compute_can_edit_body(self):
        """Can edit the body if we are not in "mass_mail" mode because the template is
        rendered before it's modified.
        """
        non_mass_mail = self.filtered(lambda m: m.composition_mode != 'mass_mail')
        non_mass_mail.can_edit_body = True
        super(MailComposer, self - non_mass_mail)._compute_can_edit_body()

    @api.model
    def get_record_data(self, values):
        """ Returns a defaults-like dict with initial values for the composition
        wizard when sending an email related a previous email (parent_id) or
        a document (model, res_id). This is based on previously computed default
        values. """
        result, subject = {}, False
        if values.get('parent_id'):
            parent = self.env['mail.message'].browse(values.get('parent_id'))
            result['record_name'] = parent.record_name
            subject = tools.ustr(parent.subject or parent.record_name or '')
            if not values.get('model'):
                result['model'] = parent.model
            if not values.get('res_id'):
                result['res_id'] = parent.res_id
            partner_ids = values.get('partner_ids', list()) + parent.partner_ids.ids
            result['partner_ids'] = partner_ids
        elif values.get('model') and values.get('res_id'):
            doc_name_get = self.env[values.get('model')].browse(values.get('res_id')).name_get()
            result['record_name'] = doc_name_get and doc_name_get[0][1] or ''
            subject = tools.ustr(result['record_name'])

        re_prefix = _('Re:')
        if subject and not (subject.startswith('Re:') or subject.startswith(re_prefix)):
            subject = "%s %s" % (re_prefix, subject)
        result['subject'] = subject

        return result

    # ------------------------------------------------------------
    # CRUD / ORM
    # ------------------------------------------------------------

    @api.autovacuum
    def _gc_lost_attachments(self):
        """ Garbage collect lost mail attachments. Those are attachments
            - linked to res_model 'mail.compose.message', the composer wizard
            - with res_id 0, because they were created outside of an existing
                wizard (typically user input through Chatter or reports
                created on-the-fly by the templates)
            - unused since at least one day (create_date and write_date)
        """
        limit_date = fields.Datetime.subtract(fields.Datetime.now(), days=1)
        self.env['ir.attachment'].search([
            ('res_model', '=', self._name),
            ('res_id', '=', 0),
            ('create_date', '<', limit_date),
            ('write_date', '<', limit_date)]
        ).unlink()

    # ------------------------------------------------------------
    # ACTIONS
    # ------------------------------------------------------------

    def action_send_mail(self):
        """ Used for action button that do not accept arguments. """
        self._action_send_mail(auto_commit=False)
        return {'type': 'ir.actions.act_window_close'}

    def _action_send_mail(self, auto_commit=False):
        """ Process the wizard content and proceed with sending the related
            email(s), rendering any template patterns on the fly if needed.

        :return tuple: (
            result_mails_su: in mass mode, sent emails (as sudo),
            result_messages: in comment mode, posted messages
        )
        """
        # Several custom layouts make use of the model description at rendering, e.g. in the
        # 'View <document>' button. Some models are used for different business concepts, such as
        # 'purchase.order' which is used for a RFQ and and PO. To avoid confusion, we must use a
        # different wording depending on the state of the object.
        # Therefore, we can set the description in the context from the beginning to avoid falling
        # back on the regular display_name retrieved in ``_notify_by_email_prepare_rendering_context()``.
        model_description = self._context.get('model_description')
        result_mails_su, result_messages = self.env['mail.mail'].sudo(), self.env['mail.message']

        for wizard in self:
            # Duplicate attachments linked to the email.template.
            # Indeed, basic mail.compose.message wizard duplicates attachments in mass
            # mailing mode. But in 'single post' mode, attachments of an email template
            # also have to be duplicated to avoid changing their ownership.
            if wizard.attachment_ids and wizard.composition_mode != 'mass_mail' and wizard.template_id:
                new_attachment_ids = []
                for attachment in wizard.attachment_ids:
                    if attachment in wizard.template_id.attachment_ids:
                        new_attachment_ids.append(attachment.copy({'res_model': 'mail.compose.message', 'res_id': wizard.id}).id)
                    else:
                        new_attachment_ids.append(attachment.id)
                new_attachment_ids.reverse()
                wizard.write({'attachment_ids': [Command.set(new_attachment_ids)]})

            # Mass Mailing
            mass_mode = wizard.composition_mode in ('mass_mail', 'mass_post')

            ActiveModel = self.env[wizard.model] if wizard.model and hasattr(self.env[wizard.model], 'message_post') else self.env['mail.thread']
            if wizard.composition_mode == 'mass_post':
                # do not send emails directly but use the queue instead
                # add context key to avoid subscribing the author
                ActiveModel = ActiveModel.with_context(mail_notify_force_send=False, mail_create_nosubscribe=True)
            # wizard works in batch mode: [res_id] or active_ids or active_domain
            if mass_mode and wizard.use_active_domain and wizard.model:
                res_ids = self.env[wizard.model].search(ast.literal_eval(wizard.active_domain)).ids
            elif mass_mode and wizard.model and self._context.get('active_ids'):
                res_ids = self._context['active_ids']
            else:
                res_ids = [wizard.res_id]

            batch_size = int(self.env['ir.config_parameter'].sudo().get_param('mail.batch_size')) or self._batch_size
            sliced_res_ids = [res_ids[i:i + batch_size] for i in range(0, len(res_ids), batch_size)]

            if wizard.composition_mode == 'mass_mail' or wizard.is_log or (wizard.composition_mode == 'mass_post' and not wizard.notify):  # log a note: subtype is False
                subtype_id = False
            elif wizard.subtype_id:
                subtype_id = wizard.subtype_id.id
            else:
                subtype_id = self.env['ir.model.data']._xmlid_to_res_id('mail.mt_comment')

            for res_ids in sliced_res_ids:
                # mass mail mode: mail are sudo-ed, as when going through get_mail_values
                # standard access rights on related records will be checked when browsing them
                # to compute mail values. If people have access to the records they have rights
                # to create lots of emails in sudo as it is consdiered as a technical model.
                batch_mails_sudo = self.env['mail.mail'].sudo()
                all_mail_values = wizard.get_mail_values(res_ids)
                for res_id, mail_values in all_mail_values.items():
                    if wizard.composition_mode == 'mass_mail':
                        batch_mails_sudo += self.env['mail.mail'].sudo().create(mail_values)
                    else:
                        post_params = dict(
                            subtype_id=subtype_id,
                            email_layout_xmlid=wizard.email_layout_xmlid,
                            email_add_signature=not bool(wizard.template_id) and wizard.email_add_signature,
                            mail_auto_delete=wizard.template_id.auto_delete if wizard.template_id else self._context.get('mail_auto_delete', True),
                            model_description=model_description)
                        post_params.update(mail_values)
                        if ActiveModel._name == 'mail.thread':
                            if wizard.model:
                                post_params['model'] = wizard.model
                                post_params['res_id'] = res_id
                            if not ActiveModel.message_notify(**post_params):
                                # if message_notify returns an empty record set, no recipients where found.
                                raise UserError(_("No recipient found."))
                        else:
                            result_messages += ActiveModel.browse(res_id).message_post(**post_params)

                result_mails_su += batch_mails_sudo
                if wizard.composition_mode == 'mass_mail':
                    batch_mails_sudo.send(auto_commit=auto_commit)

        return result_mails_su, result_messages

    def action_save_as_template(self):
        """ hit save as template button: current form value will be a new
            template attached to the current document. """
        for record in self:
            model = self.env['ir.model']._get(record.model or 'mail.message')
            model_name = model.name or ''
            template_name = "%s: %s" % (model_name, tools.ustr(record.subject))
            values = {
                'name': template_name,
                'subject': record.subject or False,
                'body_html': record.body or False,
                'model_id': model.id or False,
                'use_default_to': True,
            }
            template = self.env['mail.template'].create(values)

            if record.attachment_ids:
                attachments = self.env['ir.attachment'].sudo().browse(record.attachment_ids.ids).filtered(
                    lambda a: a.res_model == 'mail.compose.message' and a.create_uid.id == self._uid)
                if attachments:
                    attachments.write({'res_model': template._name, 'res_id': template.id})
                template.attachment_ids |= record.attachment_ids

            # generate the saved template
            record.write({'template_id': template.id})
            record._onchange_template_id_wrapper()
            return _reopen(self, record.id, record.model, context=self._context)

    # ------------------------------------------------------------
    # RENDERING / VALUES GENERATION
    # ------------------------------------------------------------

    def get_mail_values(self, res_ids):
        """Generate the values that will be used by send_mail to create mail_messages
        or mail_mails. """
        self.ensure_one()
        results = dict.fromkeys(res_ids, False)
        rendered_values = {}
        mass_mail_mode = self.composition_mode == 'mass_mail'

        # render all template-based value at once
        if mass_mail_mode and self.model:
            rendered_values = self.render_message(res_ids)
        # compute alias-based reply-to in batch
        reply_to_value = dict.fromkeys(res_ids, None)
        if mass_mail_mode and not self.reply_to_force_new:
            records = self.env[self.model].browse(res_ids)
            reply_to_value = records._notify_get_reply_to(default=False)
            # when having no specific reply-to, fetch rendered email_from value
            for res_id, reply_to in reply_to_value.items():
                if not reply_to:
                    reply_to_value[res_id] = rendered_values.get(res_id, {}).get('email_from', False)

        for res_id in res_ids:
            # static wizard (mail.message) values
            mail_values = {
                'subject': self.subject,
                'body': self.body or '',
                'parent_id': self.parent_id and self.parent_id.id,
                'partner_ids': [partner.id for partner in self.partner_ids],
                'attachment_ids': [attach.id for attach in self.attachment_ids],
                'author_id': self.author_id.id,
                'email_from': self.email_from,
                'record_name': self.record_name,
                'reply_to_force_new': self.reply_to_force_new,
                'mail_server_id': self.mail_server_id.id,
                'mail_activity_type_id': self.mail_activity_type_id.id,
                'message_type': 'email' if mass_mail_mode else self.message_type,
            }

            # mass mailing: rendering override wizard static values
            if mass_mail_mode and self.model:
                record = self.env[self.model].browse(res_id)
                mail_values['headers'] = repr(record._notify_by_email_get_headers())
                # keep a copy unless specifically requested, reset record name (avoid browsing records)
                mail_values.update(is_notification=not self.auto_delete_message, model=self.model, res_id=res_id, record_name=False)
                # auto deletion of mail_mail
                if self.auto_delete or self.template_id.auto_delete:
                    mail_values['auto_delete'] = True
                # rendered values using template
                email_dict = rendered_values[res_id]
                mail_values['partner_ids'] += email_dict.pop('partner_ids', [])
                mail_values.update(email_dict)
                if not self.reply_to_force_new:
                    mail_values.pop('reply_to')
                    if reply_to_value.get(res_id):
                        mail_values['reply_to'] = reply_to_value[res_id]
                if self.reply_to_force_new and not mail_values.get('reply_to'):
                    mail_values['reply_to'] = mail_values['email_from']
                # mail_mail values: body -> body_html, partner_ids -> recipient_ids
                mail_values['body_html'] = mail_values.get('body', '')
                mail_values['recipient_ids'] = [Command.link(id) for id in mail_values.pop('partner_ids', [])]

                # process attachments: should not be encoded before being processed by message_post / mail_mail create
                mail_values['attachments'] = [(name, base64.b64decode(enc_cont)) for name, enc_cont in email_dict.pop('attachments', list())]
                attachment_ids = []
                for attach_id in mail_values.pop('attachment_ids'):
                    new_attach_id = self.env['ir.attachment'].browse(attach_id).copy({'res_model': self._name, 'res_id': self.id})
                    attachment_ids.append(new_attach_id.id)
                attachment_ids.reverse()
                mail_values['attachment_ids'] = self.env['mail.thread'].with_context(attached_to=record)._message_post_process_attachments(
                    mail_values.pop('attachments', []),
                    attachment_ids,
                    {'model': 'mail.message', 'res_id': 0}
                )['attachment_ids']

            results[res_id] = mail_values

        results = self._process_state(results)
        return results

    def _process_recipient_values(self, mail_values_dict):
        # Preprocess res.partners to batch-fetch from db if recipient_ids is present
        # it means they are partners (the only object to fill get_default_recipient this way)
        recipient_pids = [
            recipient_command[1]
            for mail_values in mail_values_dict.values()
            # recipient_ids is a list of x2m command tuples at this point
            for recipient_command in mail_values.get('recipient_ids') or []
            if recipient_command[1]
        ]
        recipient_emails = {
            p.id: p.email
            for p in self.env['res.partner'].browse(set(recipient_pids))
        } if recipient_pids else {}

        recipients_info = {}
        for record_id, mail_values in mail_values_dict.items():
            # add email from email_to; if unrecognized email in email_to keep
            # it as used for further processing
            mail_to = tools.email_split_and_format(mail_values.get('email_to'))
            if not mail_to and mail_values.get('email_to'):
                mail_to.append(mail_values['email_to'])
            # add email from recipients (res.partner)
            mail_to += [
                recipient_emails[recipient_command[1]]
                for recipient_command in mail_values.get('recipient_ids') or []
                if recipient_command[1]
            ]
            # uniquify, keep ordering
            seen = set()
            mail_to = [email for email in mail_to if email not in seen and not seen.add(email)]

            recipients_info[record_id] = {
                'mail_to': mail_to,
                'mail_to_normalized': [
                    tools.email_normalize(mail, strict=False)
                    for mail in mail_to
                    if tools.email_normalize(mail, strict=False)
                ]
            }
        return recipients_info

    def _process_state(self, mail_values_dict):
        recipients_info = self._process_recipient_values(mail_values_dict)
        blacklist_ids = self._get_blacklist_record_ids(mail_values_dict, recipients_info)
        optout_emails = self._get_optout_emails(mail_values_dict)
        done_emails = self._get_done_emails(mail_values_dict)
        # in case of an invoice e.g.
        mailing_document_based = self.env.context.get('mailing_document_based')

        for record_id, mail_values in mail_values_dict.items():
            recipients = recipients_info[record_id]
            # when having more than 1 recipient: we cannot really decide when a single
            # email is linked to several to -> skip that part. Mass mailing should
            # anyway always have a single recipient per record as this is default behavior.
            if len(recipients['mail_to']) > 1:
                continue

            mail_to = recipients['mail_to'][0] if recipients['mail_to'] else ''
            mail_to_normalized = recipients['mail_to_normalized'][0] if recipients['mail_to_normalized'] else ''

            # prevent sending to blocked addresses that were included by mistake
            # blacklisted or optout or duplicate -> cancel
            if record_id in blacklist_ids:
                mail_values['state'] = 'cancel'
                mail_values['failure_type'] = 'mail_bl'
                # Do not post the mail into the recipient's chatter
                mail_values['is_notification'] = False
            elif optout_emails and mail_to in optout_emails:
                mail_values['state'] = 'cancel'
                mail_values['failure_type'] = 'mail_optout'
            elif done_emails and mail_to in done_emails and not mailing_document_based:
                mail_values['state'] = 'cancel'
                mail_values['failure_type'] = 'mail_dup'
            # void of falsy values -> error
            elif not mail_to:
                mail_values['state'] = 'cancel'
                mail_values['failure_type'] = 'mail_email_missing'
            elif not mail_to_normalized:
                mail_values['state'] = 'cancel'
                mail_values['failure_type'] = 'mail_email_invalid'
            elif done_emails is not None and not mailing_document_based:
                done_emails.append(mail_to)

        return mail_values_dict

    def _get_blacklist_record_ids(self, mail_values_dict, recipients_info=None):
        """Get record ids for which at least one recipient is black listed.

        :param dict mail_values_dict: mail values per record id
        :param dict recipients_info: optional dict of recipients info per record id
            Optional for backward compatibility but without, result can be incomplete.
        :return set: record ids with at least one black listed recipient.
        """
        blacklisted_rec_ids = set()
        if self.composition_mode == 'mass_mail':
            self.env['mail.blacklist'].flush_model(['email', 'active'])
            self._cr.execute("SELECT email FROM mail_blacklist WHERE active=true")
            blacklist = {x[0] for x in self._cr.fetchall()}
            if not blacklist:
                return blacklisted_rec_ids
            if isinstance(self.env[self.model], self.pool['mail.thread.blacklist']):
                targets = self.env[self.model].browse(mail_values_dict.keys()).read(['email_normalized'])
                # First extract email from recipient before comparing with blacklist
                blacklisted_rec_ids.update(target['id'] for target in targets
                                           if target['email_normalized'] in blacklist)
            elif recipients_info:
                # Note that we exclude the record if at least one recipient is blacklisted (-> even if not all)
                # But as commented above: Mass mailing should always have a single recipient per record.
                blacklisted_rec_ids.update(res_id for res_id, recipient_info in recipients_info.items()
                                           if blacklist & set(recipient_info['mail_to_normalized']))
        return blacklisted_rec_ids

    def _get_done_emails(self, mail_values_dict):
        return []

    def _get_optout_emails(self, mail_values_dict):
        return []

    def _onchange_template_id(self, template_id, composition_mode, model, res_id):
        r""" - mass_mailing: we cannot render, so return the template values
            - normal mode: return rendered values
            /!\ for x2many field, this onchange return command instead of ids
        """
        if template_id and composition_mode == 'mass_mail':
            template = self.env['mail.template'].browse(template_id)
            values = dict(
                (field, template[field])
                for field in ['subject', 'body_html',
                              'email_from',
                              'reply_to',
                              'mail_server_id']
                if template[field]
            )
            if template.attachment_ids:
                values['attachment_ids'] = [att.id for att in template.attachment_ids]
            if template.mail_server_id:
                values['mail_server_id'] = template.mail_server_id.id
        elif template_id:
            values = self.generate_email_for_composer(
                template_id, [res_id],
                ['subject', 'body_html',
                 'email_from',
                 'email_cc', 'email_to', 'partner_to', 'reply_to',
                 'attachment_ids', 'mail_server_id'
                ]
            )[res_id]
            # transform attachments into attachment_ids; not attached to the document because this will
            # be done further in the posting process, allowing to clean database if email not send
            attachment_ids = []
            Attachment = self.env['ir.attachment']
            for attach_fname, attach_datas in values.pop('attachments', []):
                data_attach = {
                    'name': attach_fname,
                    'datas': attach_datas,
                    'res_model': 'mail.compose.message',
                    'res_id': 0,
                    'type': 'binary',  # override default_type from context, possibly meant for another model!
                }
                attachment_ids.append(Attachment.create(data_attach).id)
            if values.get('attachment_ids', []) or attachment_ids:
                values['attachment_ids'] = [Command.set(values.get('attachment_ids', []) + attachment_ids)]
        else:
            default_values = self.with_context(
                default_composition_mode=composition_mode,
                default_model=model,
                default_res_id=res_id
            ).default_get(['composition_mode', 'model', 'res_id', 'parent_id',
                           'subject', 'body',
                           'email_from',
                           'partner_ids', 'reply_to',
                           'attachment_ids', 'mail_server_id'
                          ])
            values = dict(
                (key, default_values[key])
                for key in ['subject', 'body',
                            'email_from',
                            'partner_ids', 'reply_to',
                            'attachment_ids', 'mail_server_id'
                           ] if key in default_values)

        if template_id:  # Restore default sender if not updated on template switch (for both "mass_mail" and "comment" modes)
            if 'email_from' not in values:
                values['email_from'] = self.default_get(['email_from']).get('email_from')

        if values.get('body_html'):
            values['body'] = values.pop('body_html')

        # This onchange should return command instead of ids for x2many field.
        values = self._convert_to_write(values)

        return {'value': values}

    def render_message(self, res_ids):
        """Generate template-based values of wizard, for the document records given
        by res_ids. This method is meant to be inherited by email_template that
        will produce a more complete dictionary, using qweb templates.

        Each template is generated for all res_ids, allowing to parse the template
        once, and render it multiple times. This is useful for mass mailing where
        template rendering represent a significant part of the process.

        Default recipients are also computed, based on mail_thread method
        _message_get_default_recipients. This allows to ensure a mass mailing has
        always some recipients specified.

        :param browse wizard: current mail.compose.message browse record
        :param list res_ids: list of record ids

        :return dict results: for each res_id, the generated template values for
                              subject, body, email_from and reply_to
        """
        self.ensure_one()
        multi_mode = True
        if isinstance(res_ids, int):
            multi_mode = False
            res_ids = [res_ids]

        subjects = self._render_field('subject', res_ids)
        # We want to preserve comments in emails so as to keep mso conditionals
        bodies = self._render_field('body', res_ids, post_process=True, options={'preserve_comments': self.composition_mode == 'mass_mail'})
        emails_from = self._render_field('email_from', res_ids)
        replies_to = self._render_field('reply_to', res_ids)
        default_recipients = {}
        if not self.partner_ids:
            records = self.env[self.model].browse(res_ids).sudo()
            default_recipients = records._message_get_default_recipients()

        results = dict.fromkeys(res_ids, False)
        for res_id in res_ids:
            results[res_id] = {
                'subject': subjects[res_id],
                'body': bodies[res_id],
                'email_from': emails_from[res_id],
                'reply_to': replies_to[res_id],
            }
            results[res_id].update(default_recipients.get(res_id, dict()))

        # generate template-based values
        if self.template_id:
            template_values = self.generate_email_for_composer(
                self.template_id.id, res_ids,
                ['email_to', 'partner_to', 'email_cc', 'attachment_ids', 'mail_server_id'])
        else:
            template_values = {}

        for res_id in res_ids:
            if template_values.get(res_id):
                # recipients are managed by the template
                results[res_id].pop('partner_ids', None)
                results[res_id].pop('email_to', None)
                results[res_id].pop('email_cc', None)
                # remove attachments from template values as they should not be rendered
                template_values[res_id].pop('attachment_ids', None)
            else:
                template_values[res_id] = dict()
            # update template values by composer values
            template_values[res_id].update(results[res_id])

        return multi_mode and template_values or template_values[res_ids[0]]

    @api.model
    def generate_email_for_composer(self, template_id, res_ids, fields):
        """ Call email_template.generate_email(), get fields relevant for
            mail.compose.message, transform email_cc and email_to into partner_ids """
        multi_mode = True
        if isinstance(res_ids, int):
            multi_mode = False
            res_ids = [res_ids]

        returned_fields = fields + ['partner_ids', 'attachments']
        values = dict.fromkeys(res_ids, False)

        template_values = self.env['mail.template'].with_context(tpl_partners_only=True).browse(template_id).generate_email(res_ids, fields)
        for res_id in res_ids:
            res_id_values = dict((field, template_values[res_id][field]) for field in returned_fields if template_values[res_id].get(field))
            res_id_values['body'] = res_id_values.pop('body_html', '')
            values[res_id] = res_id_values

        return multi_mode and values or values[res_ids[0]]
=== ./wizard/mail_resend_message.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models, _, Command
from odoo.exceptions import UserError


class MailResendMessage(models.TransientModel):
    _name = 'mail.resend.message'
    _description = 'Email resend wizard'

    mail_message_id = fields.Many2one('mail.message', 'Message', readonly=True)
    partner_ids = fields.One2many('mail.resend.partner', 'resend_wizard_id', string='Recipients')
    notification_ids = fields.Many2many('mail.notification', string='Notifications', readonly=True)
    can_cancel = fields.Boolean(compute='_compute_can_cancel')
    can_resend = fields.Boolean(compute='_compute_can_resend')
    partner_readonly = fields.Boolean(compute='_compute_partner_readonly')

    @api.depends("partner_ids")
    def _compute_can_cancel(self):
        self.can_cancel = self.partner_ids.filtered(lambda p: not p.resend)

    @api.depends('partner_ids.resend')
    def _compute_can_resend(self):
        self.can_resend = any([partner.resend for partner in self.partner_ids])

    def _compute_partner_readonly(self):
        self.partner_readonly = not self.env['res.partner'].check_access_rights('write', raise_exception=False)

    @api.model
    def default_get(self, fields):
        rec = super(MailResendMessage, self).default_get(fields)
        message_id = self._context.get('mail_message_to_resend')
        if message_id:
            mail_message_id = self.env['mail.message'].browse(message_id)
            notification_ids = mail_message_id.notification_ids.filtered(lambda notif: notif.notification_type == 'email' and notif.notification_status in ('exception', 'bounce'))
            partner_ids = [Command.create({
                "partner_id": notif.res_partner_id.id,
                "name": notif.res_partner_id.name,
                "email": notif.res_partner_id.email,
                "resend": True,
                "message": notif.format_failure_reason(),
            }) for notif in notification_ids]
            has_user = any(notif.res_partner_id.user_ids for notif in notification_ids)
            if has_user:
                partner_readonly = not self.env['res.users'].check_access_rights('write', raise_exception=False)
            else:
                partner_readonly = not self.env['res.partner'].check_access_rights('write', raise_exception=False)
            rec['partner_readonly'] = partner_readonly
            rec['notification_ids'] = [Command.set(notification_ids.ids)]
            rec['mail_message_id'] = mail_message_id.id
            rec['partner_ids'] = partner_ids
        else:
            raise UserError(_('No message_id found in context'))
        return rec

    def resend_mail_action(self):
        """ Process the wizard content and proceed with sending the related
            email(s), rendering any template patterns on the fly if needed. """
        for wizard in self:
            "If a partner disappeared from partner list, we cancel the notification"
            to_cancel = wizard.partner_ids.filtered(lambda p: not p.resend).mapped("partner_id")
            to_send = wizard.partner_ids.filtered(lambda p: p.resend).mapped("partner_id")
            notif_to_cancel = wizard.notification_ids.filtered(lambda notif: notif.notification_type == 'email' and notif.res_partner_id in to_cancel and notif.notification_status in ('exception', 'bounce'))
            notif_to_cancel.sudo().write({'notification_status': 'canceled'})
            if to_send:
                message = wizard.mail_message_id
                record = self.env[message.model].browse(message.res_id) if message.is_thread_message() else self.env['mail.thread']

                email_partners_data = []
                recipients_data = self.env['mail.followers']._get_recipient_data(None, 'comment', False, pids=to_send.ids)[0]
                for pid, pdata in recipients_data.items():
                    if pid and pdata.get('notif', 'email') == 'email':
                        email_partners_data.append(pdata)

                record._notify_thread_by_email(
                    message, email_partners_data,
                    resend_existing=True,
                    send_after_commit=False
                )

            self.mail_message_id._notify_message_notification_update()
        return {'type': 'ir.actions.act_window_close'}

    def cancel_mail_action(self):
        for wizard in self:
            for notif in wizard.notification_ids:
                notif.filtered(lambda notif: notif.notification_type == 'email' and notif.notification_status in ('exception', 'bounce')).sudo().write({'notification_status': 'canceled'})
            wizard.mail_message_id._notify_message_notification_update()
        return {'type': 'ir.actions.act_window_close'}


class PartnerResend(models.TransientModel):
    _name = 'mail.resend.partner'
    _description = 'Partner with additional information for mail resend'

    partner_id = fields.Many2one('res.partner', string='Partner', required=True, ondelete='cascade')
    name = fields.Char(related='partner_id.name', string='Recipient Name', related_sudo=False, readonly=False)
    email = fields.Char(related='partner_id.email', string='Email Address', related_sudo=False, readonly=False)
    resend = fields.Boolean(string='Try Again', default=True)
    resend_wizard_id = fields.Many2one('mail.resend.message', string="Resend wizard")
    message = fields.Char(string='Error message')
=== ./wizard/__init__.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from . import base_module_uninstall
from . import base_partner_merge_automatic_wizard
from . import mail_blacklist_remove
from . import mail_compose_message
from . import mail_resend_message
from . import mail_template_preview
from . import mail_template_reset
from . import mail_wizard_invite
=== ./wizard/mail_blacklist_remove_views.xml ===
<?xml version="1.0"?>
<odoo>
    <record id="mail_blacklist_remove_view_form" model="ir.ui.view">
        <field name="name">mail.blacklist.remove.form</field>
        <field name="model">mail.blacklist.remove</field>
        <field name="arch" type="xml">
            <form string="mail_blacklist_removal">
                <group class="oe_title">
                    <field name="email" string="Email Address"/>
                    <field name="reason" string="Reason"/>
                </group>
                <footer>
                    <button name="action_unblacklist_apply" string="Confirm" type="object" class="btn-primary" data-hotkey="q"/>
                    <button string="Discard" class="btn-secondary" special="cancel" data-hotkey="z"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./wizard/mail_wizard_invite_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <!-- wizard view -->
        <record model="ir.ui.view" id="mail_wizard_invite_form">
            <field name="name">Add Followers</field>
            <field name="model">mail.wizard.invite</field>
            <field name="arch" type="xml">
                <form string="Add Followers">
                    <group>
                        <field name="res_model" invisible="1"/>
                        <field name="res_id" invisible="1"/>
                        <field name="partner_ids" widget="many2many_tags_email"
                                placeholder="Add contacts to notify..."
                                context="{'force_email':True, 'show_email':True}"/>
                        <field name="send_mail"/>
                        <field name="message" attrs="{'invisible': [('send_mail','!=',True)]}" options="{'style-inline': true, 'no-attachment': true}" class="test_message"/>
                    </group>
                    <footer>
                        <button string="Add Followers"
                            name="add_followers" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="z" />
                    </footer>
                </form>
            </field>
        </record>

    </data>
</odoo>
=== ./wizard/mail_template_reset.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import fields, models, _


class MailTemplateReset(models.TransientModel):
    _name = 'mail.template.reset'
    _description = 'Mail Template Reset'

    template_ids = fields.Many2many('mail.template')

    def reset_template(self):
        if not self.template_ids:
            return False
        self.template_ids.reset_template()
        if self.env.context.get('params', {}).get('view_type') == 'list':
            next_action = {'type': 'ir.actions.client', 'tag': 'reload'}
        else:
            next_action = {'type': 'ir.actions.act_window_close'}
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'type': 'success',
                'message': _('Mail Templates have been reset'),
                'next': next_action,
            }
        }
=== ./wizard/mail_template_reset_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="mail_template_reset_view_form" model="ir.ui.view">
        <field name="name">mail.template.reset.view.form</field>
        <field name="model">mail.template.reset</field>
        <field name="priority">1000</field>
        <field name="arch" type="xml">
            <form>
                <div>
                    Are you sure you want to reset these email templates to their original configuration? Changes and translations will be lost.
                </div>
                <footer>
                    <button string="Proceed" class="btn btn-primary" type="object" name="reset_template" data-hotkey="q"/>
                    <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="z"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="mail_template_reset_action" model="ir.actions.act_window">
        <field name="name">Reset Mail Template</field>
        <field name="res_model">mail.template.reset</field>
        <field name="binding_model_id" ref="mail.model_mail_template"/>
        <field name="binding_view_types">list</field>
        <field name="type">ir.actions.act_window</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="context">{
            'default_template_ids': active_ids
        }</field>
        <field name="view_id" ref="mail_template_reset_view_form"/>
    </record>
</odoo>
=== ./wizard/mail_resend_message_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="mail_resend_message_view_form" model="ir.ui.view">
            <field name="name">mail.resend.message.view.form</field>
            <field name="model">mail.resend.message</field>
            <field name="groups_id" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="arch" type="xml">
                <form string="Edit Partners">
                    <field name="mail_message_id" invisible="1"/>
                    <field name="notification_ids" invisible="1"/>
                    <field name="can_resend" invisible="1"/>
                    <field name="partner_readonly" invisible="1"/>
                    <field name="partner_ids">
                        <tree string="Recipient" editable="top" create="0" delete="0">
                            <field name="name" readonly="1"/>
                            <field name="email" attrs="{'readonly': [('parent.partner_readonly', '=', True)]}"/>
                            <field name="message" readonly="1" class="text-wrap"/>
                            <field name="partner_id" invisible="1"/>
                            <field name="resend" widget="boolean_toggle"/>
                        </tree>
                    </field>
                    <footer>
                        <button string="Send &amp; close" name="resend_mail_action" type="object" class="btn-primary o_mail_send"
                                attrs="{'invisible': [('can_resend', '=', False)]}" data-hotkey="q"/>
                        <button string="Ignore all" name="cancel_mail_action" type="object" class="btn-primary"
                                attrs="{'invisible': [('can_resend', '=', True)]}" data-hotkey="w"/>
                        <button string="Ignore all" name="cancel_mail_action" type="object" class="btn-secondary"
                                attrs="{'invisible': [('can_resend', '=', False)]}" data-hotkey="w"/>
                        <button string="Close" class="btn-secondary" special="cancel" data-hotkey="z"/>
                    </footer>
                </form>
            </field>
        </record>
        <record id="mail_resend_message_action" model="ir.actions.act_window">
            <field name="name">Sending Failures</field>
            <field name="res_model">mail.resend.message</field>
            <field name="type">ir.actions.act_window</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
        </record>
    </data>
</odoo>
=== ./wizard/mail_wizard_invite.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from lxml import etree
from lxml.html import builder as html

from odoo import _, api, fields, models
from odoo.exceptions import UserError


class Invite(models.TransientModel):
    """ Wizard to invite partners (or channels) and make them followers. """
    _name = 'mail.wizard.invite'
    _description = 'Invite wizard'

    @api.model
    def default_get(self, fields):
        result = super(Invite, self).default_get(fields)
        if 'message' not in fields:
            return result

        user_name = self.env.user.display_name
        model = result.get('res_model')
        res_id = result.get('res_id')
        if model and res_id:
            document = self.env['ir.model']._get(model).display_name
            title = self.env[model].browse(res_id).display_name
            msg_fmt = _('%(user_name)s invited you to follow %(document)s document: %(title)s')
        else:
            msg_fmt = _('%(user_name)s invited you to follow a new document.')

        text = msg_fmt % locals()
        message = html.DIV(
            html.P(_('Hello,')),
            html.P(text)
        )
        result['message'] = etree.tostring(message)
        return result

    res_model = fields.Char('Related Document Model', required=True, help='Model of the followed resource')
    res_id = fields.Integer('Related Document ID', help='Id of the followed resource')
    partner_ids = fields.Many2many('res.partner', string='Recipients', help="List of partners that will be added as follower of the current document.",
                                   domain=[('type', '!=', 'private')])
    message = fields.Html('Message')
    send_mail = fields.Boolean('Send Email', default=True, help="If checked, the partners will receive an email warning they have been added in the document's followers.")

    def add_followers(self):
        if not self.env.user.email:
            raise UserError(_("Unable to post message, please configure the sender's email address."))
        email_from = self.env.user.email_formatted
        for wizard in self:
            Model = self.env[wizard.res_model]
            document = Model.browse(wizard.res_id)

            # filter partner_ids to get the new followers, to avoid sending email to already following partners
            new_partners = wizard.partner_ids - document.sudo().message_partner_ids
            document.message_subscribe(partner_ids=new_partners.ids)

            model_name = self.env['ir.model']._get(wizard.res_model).display_name
            # send an email if option checked and if a message exists (do not send void emails)
            if wizard.send_mail and wizard.message and not wizard.message == '<br>':  # when deleting the message, cleditor keeps a <br>
                message = self.env['mail.message'].create(
                    self._prepare_message_values(document, model_name, email_from)
                )
                email_partners_data = []
                recipients_data = self.env['mail.followers']._get_recipient_data(document, 'comment', False, pids=new_partners.ids)[document.id]
                for _pid, pdata in recipients_data.items():
                    pdata['notif'] = 'email'
                    email_partners_data.append(pdata)

                document._notify_thread_by_email(
                    message, email_partners_data,
                    send_after_commit=False
                )
                # in case of failure, the web client must know the message was
                # deleted to discard the related failure notification
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'mail.message/delete', {'message_ids': message.ids})
                message.unlink()
        return {'type': 'ir.actions.act_window_close'}

    def _prepare_message_values(self, document, model_name, email_from):
        return {
            'subject': _('Invitation to follow %(document_model)s: %(document_name)s', document_model=model_name,
                         document_name=document.display_name),
            'body': self.message,
            'record_name': document.display_name,
            'email_from': email_from,
            'reply_to': email_from,
            'model': self.res_model,
            'res_id': self.res_id,
            'reply_to_force_new': True,
            'email_add_signature': True,
        }
=== ./wizard/mail_template_preview.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models
from odoo.exceptions import UserError


class MailTemplatePreview(models.TransientModel):
    _name = 'mail.template.preview'
    _description = 'Email Template Preview'
    _MAIL_TEMPLATE_FIELDS = ['subject', 'body_html', 'email_from', 'email_to',
                             'email_cc', 'reply_to', 'scheduled_date', 'attachment_ids']

    @api.model
    def _selection_target_model(self):
        return [(model.model, model.name) for model in self.env['ir.model'].sudo().search([])]

    @api.model
    def _selection_languages(self):
        return self.env['res.lang'].get_installed()

    @api.model
    def default_get(self, fields):
        result = super(MailTemplatePreview, self).default_get(fields)
        if not result.get('mail_template_id') or 'resource_ref' not in fields:
            return result
        mail_template = self.env['mail.template'].browse(result['mail_template_id']).sudo()
        model = mail_template.model
        res = self.env[model].search([], limit=1)
        if res:
            result['resource_ref'] = '%s,%s' % (model, res.id)
        return result

    mail_template_id = fields.Many2one('mail.template', string='Related Mail Template', required=True)
    model_id = fields.Many2one('ir.model', string='Targeted model', related="mail_template_id.model_id")
    resource_ref = fields.Reference(string='Record', selection='_selection_target_model')
    lang = fields.Selection(_selection_languages, string='Template Preview Language')
    no_record = fields.Boolean('No Record', compute='_compute_no_record')
    error_msg = fields.Char('Error Message', readonly=True)
    # Fields same than the mail.template model, computed with resource_ref and lang
    subject = fields.Char('Subject', compute='_compute_mail_template_fields')
    email_from = fields.Char('From', compute='_compute_mail_template_fields', help="Sender address")
    email_to = fields.Char('To', compute='_compute_mail_template_fields',
                           help="Comma-separated recipient addresses")
    email_cc = fields.Char('Cc', compute='_compute_mail_template_fields', help="Carbon copy recipients")
    reply_to = fields.Char('Reply-To', compute='_compute_mail_template_fields', help="Preferred response address")
    scheduled_date = fields.Char('Scheduled Date', compute='_compute_mail_template_fields',
                                 help="The queue manager will send the email after the date")
    body_html = fields.Html('Body', compute='_compute_mail_template_fields', sanitize=False)
    attachment_ids = fields.Many2many('ir.attachment', 'Attachments', compute='_compute_mail_template_fields')
    # Extra fields info generated by generate_email
    partner_ids = fields.Many2many('res.partner', string='Recipients', compute='_compute_mail_template_fields')

    @api.depends('model_id')
    def _compute_no_record(self):
        for preview, preview_sudo in zip(self, self.sudo()):
            model_id = preview_sudo.model_id
            preview.no_record = not model_id or not self.env[model_id.model].search_count([])

    @api.depends('lang', 'resource_ref')
    def _compute_mail_template_fields(self):
        """ Preview the mail template (body, subject, ...) depending of the language and
        the record reference, more precisely the record id for the defined model of the mail template.
        If no record id is selectable/set, the inline_template placeholders won't be replace in the display information. """
        copy_depends_values = {'lang': self.lang}
        mail_template = self.mail_template_id.with_context(lang=self.lang)
        try:
            if not self.resource_ref:
                self._set_mail_attributes()
            else:
                copy_depends_values['resource_ref'] = '%s,%s' % (self.resource_ref._name, self.resource_ref.id)
                mail_values = mail_template.with_context(template_preview_lang=self.lang).generate_email(
                    self.resource_ref.id, self._MAIL_TEMPLATE_FIELDS + ['partner_to'])
                self._set_mail_attributes(values=mail_values)
            self.error_msg = False
        except UserError as user_error:
            self._set_mail_attributes()
            self.error_msg = user_error.args[0]
        finally:
            # Avoid to be change by a cache invalidation (in generate_mail), e.g. Quotation / Order report
            for key, value in copy_depends_values.items():
                self[key] = value

    def _set_mail_attributes(self, values=None):
        for field in self._MAIL_TEMPLATE_FIELDS:
            field_value = values.get(field, False) if values else self.mail_template_id[field]
            self[field] = field_value
        self.partner_ids = values.get('partner_ids', False) if values else False
=== ./wizard/mail_template_preview_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="mail_template_preview_view_form" model="ir.ui.view">
            <field name="name">mail.template.preview.view.form</field>
            <field name="model">mail.template.preview</field>
            <field name="arch" type="xml">
                <form string="Email Preview">
                    <h3>Preview of <field name="mail_template_id" readonly="1" nolabel="1" options="{'no_open' : True}"/></h3>
                    <div class="alert alert-danger" role="alert" attrs="{'invisible' : [('error_msg', '=', False)]}">
                        <field name="error_msg" widget="text"/>
                    </div>
                    <field name="no_record" invisible="1"/>
                    <div class="container">
                        <div class="row">
                            <span class="col-md-5 col-lg-4 col-sm-12 ps-0">Choose an example <field name="model_id" readonly="1"/> record:</span>
                            <div class="col-md-7 col-lg-6 col-sm-12 ps-0">
                                <field name="resource_ref" readonly="False" class="w-100"
                                    options="{'hide_model': True, 'no_create': True, 'no_open': True}"
                                    attrs="{'invisible': [('no_record', '=', True)]}"/>
                                <b attrs="{'invisible': [('no_record', '=', False)]}" class="text-warning">No record for this model</b>
                            </div>
                        </div>
                        <div class="row">
                            <span class="col-md-5 col-lg-4 col-sm-12 ps-0">Force a language: </span>
                            <div class="col-md-7 col-lg-6 col-sm-12 ps-0">
                                <field name="lang" placeholder="Select a language" class="w-100"/>
                            </div>
                        </div>
                    </div>
                    <group>
                        <field name="subject"/>
                        <field name="email_from" attrs="{'invisible':[('email_from','=', False)]}"/>
                        <field name="partner_ids" widget="many2many_tags" attrs="{'invisible':[('partner_ids', '=', [])]}"/>
                        <field name="email_to" attrs="{'invisible':[('email_to','=', False)]}"/>
                        <field name="email_cc" attrs="{'invisible':[('email_cc','=', False)]}"/>
                        <field name="reply_to" attrs="{'invisible':[('reply_to','=', False)]}"/>
                        <field name="scheduled_date" attrs="{'invisible':[('scheduled_date','=', False)]}"/>
                    </group>
                    <field name="body_html" widget="html" nolabel="1" options='{"safe": True}'/>
                    <field name="attachment_ids" widget="many2many_binary"/>
                    <footer>
                        <button string="Close" class="btn-secondary" special="cancel" data-hotkey="z"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="mail_template_preview_action" model="ir.actions.act_window">
            <field name="name">Template Preview</field>
            <field name="res_model">mail.template.preview</field>
            <field name="binding_model_id" eval="False"/>
            <field name="type">ir.actions.act_window</field>
            <field name="view_mode">form</field>
            <field name="view_id" ref="mail_template_preview_view_form"/>
            <field name="target">new</field>
            <field name="context">{'default_mail_template_id':active_id}</field>
        </record>

    </data>
</odoo>
=== ./wizard/mail_compose_message_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record model="ir.ui.view" id="email_compose_message_wizard_form">
            <field name="name">mail.compose.message.form</field>
            <field name="model">mail.compose.message</field>
            <field name="groups_id" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="arch" type="xml">
                <form string="Compose Email" class="pt-0 pb-0 o_mail_composer_form">
                    <group>
                        <!-- truly invisible fields for control and options -->
                        <field name="author_id" invisible="1"/>
                        <field name="auto_delete" invisible="1"/>
                        <field name="auto_delete_message" invisible="1"/>
                        <field name="composition_mode" invisible="1"/>
                        <field name="email_layout_xmlid" invisible="1"/>
                        <field name="is_log" invisible="1"/>
                        <field name="mail_server_id" invisible="1"/>
                        <field name="model" invisible="1"/>
                        <field name="parent_id" invisible="1"/>
                        <field name="record_name" invisible="1"/>
                        <field name="res_id" invisible="1"/>
                        <field name="subtype_id" invisible="1"/>
                        <!-- visible wizard -->
                        <field name="email_from"
                            attrs="{'invisible':[('composition_mode', '!=', 'mass_mail')]}"/>
                        <label for="partner_ids" string="Recipients" attrs="{'invisible': ['|', ('is_log', '=', True), ('composition_mode', '!=', 'comment')]}"/>
                        <div groups="base.group_user" attrs="{'invisible': ['|', ('is_log', '=', True), ('composition_mode', '!=', 'comment')]}">
                            <span name="document_followers_text" attrs="{'invisible':['|', ('model', '=', False), ('composition_mode', '=', 'mass_mail')]}">Followers of the document and</span>
                            <field name="partner_ids" widget="many2many_tags_email" placeholder="Add contacts to notify..."
                                context="{'force_email':True, 'show_email':True}"/>
                        </div>
                        <field name="subject" placeholder="Welcome to MyCompany!" required="True"/>
                        <!-- mass post -->
                        <field name="notify"
                            attrs="{'invisible':[('composition_mode', '!=', 'mass_post')]}"/>
                    </group>
                    <field name="can_edit_body" invisible="1"/>
                    <div attrs="{'invisible': [('composition_mode', '=', 'mass_mail')]}">
                        <field name="body" class="oe-bordered-editor" placeholder="Write your message here..." options="{'style-inline': true}" attrs="{'readonly': [('can_edit_body', '=', False)]}" force_save="1"/>
                        <group col="4">
                            <field name="attachment_ids" widget="many2many_binary" string="Attach a file" nolabel="1" colspan="2"/>
                            <field name="template_id" string="Load template" options="{'no_create': True}"
                                context="{'default_model': model, 'default_body_html': body, 'default_subject': subject}"/>
                        </group>
                    </div>
                    <notebook attrs="{'invisible': [('composition_mode', '!=', 'mass_mail')]}">
                        <page string="Content">
                            <div>
                                <field name="body" class="oe-bordered-editor" placeholder="Write your message here..." options="{'style-inline': true}" attrs="{'readonly': [('can_edit_body', '=', False)]}" force_save="1"/>
                                <group col="4">
                                    <field name="attachment_ids" widget="many2many_binary" string="Attach a file" nolabel="1" colspan="2"/>
                                    <field name="template_id" string="Load template" options="{'no_create': True}"
                                        context="{'default_model': model, 'default_body_html': body, 'default_subject': subject}"/>
                                </group>
                            </div>
                        </page>
                        <page string="Settings">
                            <!-- mass mailing -->
                            <field name="reply_to_force_new" invisible="1"/>
                            <field name="reply_to_mode" attrs="{'invisible':[('composition_mode', '!=', 'mass_mail')]}" widget="radio"/>
                            <group>
                                <field name="reply_to" string="Reply-to Address" placeholder='e.g: "info@mycompany.odoo.com"'
                                    attrs="{'invisible':['|', ('reply_to_mode', '=', 'update'), ('composition_mode', '!=', 'mass_mail')],
                                            'required':[('reply_to_mode', '!=', 'update'), ('composition_mode', '=', 'mass_mail')]}"/>
                            </group>
                        </page>
                    </notebook>
                    <footer>
                        <button string="Send" attrs="{'invisible': [('is_log', '=', True)]}" name="action_send_mail" type="object" class="btn-primary o_mail_send" data-hotkey="q"/>
                        <button string="Log" attrs="{'invisible': [('is_log', '=', False)]}" name="action_send_mail" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="z" />
                        <button icon="fa-lg fa-save" type="object"
                                name="action_save_as_template" string="Save as new template"
                                attrs="{'invisible': [('can_edit_body', '=', False)]}"
                                class="float-end btn-secondary" help="Save as a new template" data-hotkey="w"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="action_email_compose_message_wizard" model="ir.actions.act_window">
            <field name="name">Compose Email</field>
            <field name="res_model">mail.compose.message</field>
            <field name="binding_model_id" ref="mail.model_mail_compose_message"/>
            <field name="type">ir.actions.act_window</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
        </record>
    </data>
</odoo>
=== ./wizard/base_partner_merge_automatic_wizard.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from odoo import api, models, _


class MergePartnerAutomatic(models.TransientModel):

    _inherit = 'base.partner.merge.automatic.wizard'

    def _log_merge_operation(self, src_partners, dst_partner):
        super(MergePartnerAutomatic, self)._log_merge_operation(src_partners, dst_partner)
        dst_partner.message_post(body='%s %s' % (_("Merged with the following partners:"), ", ".join('%s <%s> (ID %s)' % (p.name, p.email or 'n/a', p.id) for p in src_partners)))
=== ./wizard/mail_blacklist_remove.py ===
# -*- coding: utf-8 -*-

from odoo import fields, models


class MailBlacklistRemove(models.TransientModel):
    _name = 'mail.blacklist.remove'
    _description = 'Remove email from blacklist wizard'

    email = fields.Char(name="Email", readonly=True, required=True)
    reason = fields.Char(name="Reason")

    def action_unblacklist_apply(self):
        return self.env['mail.blacklist'].action_remove_with_reason(self.email, self.reason)
=== ./wizard/base_module_uninstall.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import models


class BaseModuleUninstall(models.TransientModel):
    _inherit = "base.module.uninstall"

    def _get_models(self):
        # consider mail-thread models only
        models = super(BaseModuleUninstall, self)._get_models()
        return models.filtered('is_mail_thread')
odoo@5cfc0603deef:~/odoo/addons/mail$ find ./security -type f -exec echo "=== {} ===" \; -exec cat {} \;
=== ./security/mail_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo noupdate="1">

        <!-- RULES -->
        <record id="mail_channel_rule" model="ir.rule">
            <field name="name">Mail.channel: access only public and joined groups</field>
            <field name="model_id" ref="model_mail_channel"/>
            <field name="groups" eval="[Command.link(ref('base.group_user')), Command.link(ref('base.group_portal')), Command.link(ref('base.group_public'))]"/>
            <field name="domain_force">[
                '|',
                    '&amp;',
                        ('channel_type', '!=', 'channel'),
                        ('is_member', '=', True),
                    '&amp;',
                        ('channel_type', '=', 'channel'),
                        '|',
                            ('group_public_id', '=', False),
                            ('group_public_id', 'in', [g.id for g in user.groups_id])]
            </field>
            <field name="perm_create" eval="False"/>
        </record>

        <record id="mail_channel_admin" model="ir.rule">
            <field name="name">Mail.channel: admin full access</field>
            <field name="model_id" ref="model_mail_channel"/>
            <field name="groups" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="domain_force">[(1, '=', 1)]</field>
        </record>

        <record id="ir_rule_mail_channel_member_group_user" model="ir.rule">
            <field name="name">mail.channel.member: write its own entries</field>
            <field name="model_id" ref="model_mail_channel_member"/>
            <field name="groups" eval="[(4, ref('base.group_user')), (4, ref('base.group_portal'))]"/>
            <field name="domain_force">[
                '|',
                    '&amp;',
                        ('channel_id.channel_type', '!=', 'channel'),
                        ('channel_id.is_member', '=', True),
                    '&amp;',
                        ('channel_id.channel_type', '=', 'channel'),
                        '|',
                            ('channel_id.group_public_id', '=', False),
                            ('channel_id.group_public_id', 'in', [g.id for g in user.groups_id])]
            </field>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="ir_rule_mail_channel_member_group_system" model="ir.rule">
            <field name="name">mail.channel.member: admin can manipulate all entries</field>
            <field name="model_id" ref="model_mail_channel_member"/>
            <field name="groups" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="domain_force">[(1, '=', 1)]</field>
        </record>

        <record id="ir_rule_mail_notifications_group_user" model="ir.rule">
            <field name="name">mail.notifications: group_user: write its own entries</field>
            <field name="model_id" ref="model_mail_notification"/>
            <field name="groups" eval="[Command.link(ref('base.group_user')), Command.link(ref('base.group_portal'))]"/>
            <field name="domain_force">[('res_partner_id', '=', user.partner_id.id)]</field>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
            <field name="perm_read" eval="False"/>
        </record>

        <record id="mail_message_subtype_rule_public" model="ir.rule">
            <field name="name">mail.message.subtype: portal/public: read public subtypes</field>
            <field name="model_id" ref="model_mail_message_subtype"/>
            <field name="domain_force">[('internal', '=', False)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_portal')), Command.link(ref('base.group_public'))]"/>
        </record>

        <record id="mail_activity_rule_user" model="ir.rule">
            <field name="name">mail.activity: user: write/unlink only (created or assigned)</field>
            <field name="model_id" ref="model_mail_activity"/>
            <field name="domain_force">['|', ('user_id', '=', user.id), ('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="mail_compose_message_rule" model="ir.rule">
            <field name="name">Mail Compose Message Rule</field>
            <field name="model_id" ref="model_mail_compose_message"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="perm_create" eval="False"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <record id="mail_template_employee_rule" model="ir.rule">
            <field name="name">Employees can only change their own templates</field>
            <field name="model_id" ref="model_mail_template"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="mail_template_editor_rule" model="ir.rule">
            <field name="name">Mail Template Editors - Edit All Templates</field>
            <field name="model_id" ref="model_mail_template"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[Command.link(ref('group_mail_template_editor')), Command.link(ref('base.group_system'))]"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="res_users_settings_rule_admin" model="ir.rule">
            <field name="name">Administrators can access all User Settings.</field>
            <field name="model_id" ref="model_res_users_settings"/>
            <field name="groups" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="res_users_settings_rule_user" model="ir.rule">
            <field name="name">res.users.settings: access their own entries</field>
            <field name="model_id" ref="model_res_users_settings"/>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="domain_force">[('user_id', '=', user.id)]</field>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="res_users_settings_volumes_rule_user" model="ir.rule">
            <field name="name">res.users.settings.volumes: access their own entries</field>
            <field name="model_id" ref="model_res_users_settings_volumes"/>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="domain_force">[('user_setting_id.user_id', '=', user.id)]</field>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="res_users_settings_volumes_rule_admin" model="ir.rule">
            <field name="name">Administrators can access all User Settings volumes.</field>
            <field name="model_id" ref="model_res_users_settings_volumes"/>
            <field name="groups" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

</odoo>
=== ./security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_fetchmail_server,fetchmail.server,model_fetchmail_server,base.group_system,1,1,1,1
access_mail_message_all,mail.message.all,model_mail_message,,1,0,0,0
access_mail_message_portal,mail.message.portal,model_mail_message,base.group_portal,1,1,1,1
access_mail_message_user,mail.message.user,model_mail_message,base.group_user,1,1,1,1
access_mail_message_scheduled_all,mail.message.scheduled.all,model_mail_message_schedule,,0,0,0,0
access_mail_message_scheduled_system,mail.message.scheduled.system,model_mail_message_schedule,base.group_system,1,1,1,1
access_mail_mail_all,mail.mail.all,model_mail_mail,,0,0,0,0
access_mail_mail_portal,mail.mail.portal,model_mail_mail,base.group_portal,0,0,0,0
access_mail_mail_user,mail.mail.user,model_mail_mail,base.group_user,0,0,0,0
access_mail_mail_system,mail.mail.system,model_mail_mail,base.group_system,1,1,1,1
access_mail_followers_all,mail.followers.all,model_mail_followers,,0,0,0,0
access_mail_followers_user,mail.followers.user,model_mail_followers,base.group_user,1,0,0,0
access_mail_followers_system,mail.followers.system,model_mail_followers,base.group_system,1,1,1,1
access_mail_notification_portal,mail.notification.portal,model_mail_notification,base.group_portal,1,0,0,0
access_mail_notification_user,mail.notification.user,model_mail_notification,base.group_user,1,1,1,0
access_mail_notification_system, mail.notification.system,model_mail_notification,base.group_system,1,1,1,1
access_mail_channel_all,mail.group.all,model_mail_channel,,1,0,0,0
access_mail_channel_user,mail.group.user,model_mail_channel,base.group_user,1,1,1,0
access_mail_channel_admin,mail.group.system,model_mail_channel,base.group_system,1,1,1,1
access_mail_channel_member_public,mail.channel.member.public,model_mail_channel_member,base.group_public,1,0,0,0
access_mail_channel_member_portal,mail.channel.member.portal,model_mail_channel_member,base.group_portal,1,1,1,1
access_mail_channel_member_user,mail.channel.member.user,model_mail_channel_member,base.group_user,1,1,1,1
access_mail_channel_rtc_session_all,mail.channel.rtc.session.all,model_mail_channel_rtc_session,,0,0,0,0
access_mail_channel_rtc_session_system,mail.channel.rtc.session.system,model_mail_channel_rtc_session,base.group_system,1,1,1,1
access_mail_alias_all,mail.alias.all,model_mail_alias,,1,0,0,0
access_mail_alias_user,mail.alias.user,model_mail_alias,base.group_user,1,0,0,0
access_mail_alias_system,mail.alias.system,model_mail_alias,base.group_system,1,1,1,1
access_mail_gateway_allowed_system,mail.gateway.allowed.system,model_mail_gateway_allowed,base.group_system,1,1,1,1
access_mail_message_reaction_all,mail.message.reaction.all,model_mail_message_reaction,,0,0,0,0
access_mail_message_reaction_system,mail.message.reaction.system,model_mail_message_reaction,base.group_system,1,1,1,1
access_mail_message_subtype_all,mail.message.subtype.all,model_mail_message_subtype,,1,0,0,0
access_mail_message_subtype_user,mail.message.subtype.user,model_mail_message_subtype,base.group_user,1,0,0,0
access_mail_message_subtype_system,mail.message.subtype.system,model_mail_message_subtype,base.group_system,1,1,1,1
access_mail_tracking_value_all,mail.tracking.value.all,model_mail_tracking_value,,0,0,0,0
access_mail_tracking_value_portal,mail.tracking.value.portal,model_mail_tracking_value,base.group_portal,0,0,0,0
access_mail_tracking_value_user,mail.tracking.value.user,model_mail_tracking_value,base.group_user,0,0,0,0
access_mail_tracking_value_system,mail.tracking.value.system,model_mail_tracking_value,base.group_system,1,1,1,1
access_publisher_warranty_contract_all,publisher.warranty.contract.all,model_publisher_warranty_contract,,1,1,1,1
access_mail_template,mail.template,model_mail_template,base.group_user,1,1,1,1
access_mail_template_editor,mail.template_editor,model_mail_template,mail.group_mail_template_editor,1,1,1,1
access_mail_template_system,mail.template_system,model_mail_template,base.group_system,1,1,1,1
access_mail_shortcode,mail.shortcode,model_mail_shortcode,base.group_user,1,1,1,1
access_mail_shortcode_portal,mail.shortcode.portal,model_mail_shortcode,base.group_portal,1,0,0,0
access_mail_activity_all,mail.activity.all,model_mail_activity,,0,0,0,0
access_mail_activity_user,mail.activity.user,model_mail_activity,base.group_user,1,1,1,1
access_mail_activity_type_all,mail.activity.type.all,model_mail_activity_type,,0,0,0,0
access_mail_activity_type_user,mail.activity.type.user,model_mail_activity_type,base.group_user,1,0,0,0
access_mail_activity_type_system,mail.activity.type.system,model_mail_activity_type,base.group_system,1,1,1,1
access_mail_blacklist_system,access_mail_blacklist_system,model_mail_blacklist,base.group_system,1,1,1,1
access_mail_wizard_invite,access.mail.wizard.invite,model_mail_wizard_invite,base.group_user,1,1,1,0
access_mail_compose_message,access.mail.compose.message,model_mail_compose_message,base.group_user,1,1,1,0
access_mail_compose_message_portal,access.mail.compose.message.portal,model_mail_compose_message,base.group_portal,1,1,1,0
access_mail_resend_message,access.mail.resend.message,model_mail_resend_message,base.group_user,1,1,1,0
access_mail_resend_partner,access.mail.resend.partner,model_mail_resend_partner,base.group_user,1,1,1,0
access_mail_template_preview,access.mail.template.preview,model_mail_template_preview,base.group_user,1,1,1,0
access_mail_blacklist_remove_system,acesss.mail.blacklist.remove.system,model_mail_blacklist_remove,base.group_system,1,1,1,1
access_mail_guest_all,mail.guest,model_mail_guest,,0,0,0,0
access_mail_guest_user,mail.guest,model_mail_guest,base.group_user,1,0,0,0
access_mail_guest_system,mail.guest,model_mail_guest,base.group_system,1,1,1,1
access_mail_ice_server_all,mail.ice.server.all,model_mail_ice_server,,0,0,0,0
access_mail_ice_server_system,mail.ice.server.system,model_mail_ice_server,base.group_system,1,1,1,1
access_res_users_settings_all,res.users.settings,model_res_users_settings,,0,0,0,0
access_res_users_settings_user,res.users.settings,model_res_users_settings,base.group_user,1,1,1,1
access_res_users_settings_volumes_all,res.users.settings.volumes,model_res_users_settings_volumes,,0,0,0,0
access_res_users_settings_volumes_user,res.users.settings.volumes,model_res_users_settings_volumes,base.group_user,1,1,1,1
access_mail_template_reset,access.mail.template.reset,model_mail_template_reset,mail.group_mail_template_editor,1,1,1,1
ir_actions_report_access_user,ir.actions.report.access.user,base.model_ir_actions_report,base.group_user,1,0,0,0
access_mail_link_preview_admin,mail.link.preview.admin,model_mail_link_preview,base.group_erp_manager,1,1,1,1
odoo@5cfc0603deef:~/odoo/addons/mail$ find ./data -type f -exec echo "=== {} ===" \; -exec cat {} \;
=== ./data/mail_templates_chatter.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Discuss utility templates for notifications -->
        <template id="message_user_assigned">
    <span>Dear <t t-esc="object.user_id.sudo().name"/>,</span>
    <br/><br/>
    <span style="margin-top: 8px;">You have been assigned to the <t t-esc="model_description or 'document'"/> <t t-esc="object.display_name"/>.</span>
    <br/>
        </template>

        <template id="message_activity_done">
<div>
    <p>
        <span t-attf-class="fa #{activity.activity_type_id.icon} fa-fw"/><span t-field="activity.activity_type_id.name"/> done
        <t t-if="display_assignee"> (originally assigned to <span t-field="activity.user_id.name"/>)</t>
        <span t-if="activity.summary">: </span><span t-if="activity.summary" t-field="activity.summary"/>
    </p>
    <div t-if="feedback">
        <t t-foreach="feedback.split('\n')" t-as="feedback_line">
            <t t-esc="feedback_line"/>
            <br t-if="not feedback_line_last"/>
        </t>
    </div>
    <t t-if="activity.note and activity.note != '&lt;p&gt;&lt;br&gt;&lt;/p&gt;'"><!-- <p></br></p> -->
        <div class="o_mail_note_title"><strong>Original note:</strong></div>
        <div t-field="activity.note"/>
    </t>
</div>
        </template>

        <template id="message_activity_assigned">
<div style="margin: 0px; padding: 0px; font-size: 13px;">
    Dear <span t-field="activity.user_id.name"/>,
    <br/><br/>
    <p>
        <span t-field="activity.create_uid.name"/> has just assigned you the following activity:
        <ul>
            <li>Document: "<t t-esc="activity.res_name"/>"
                <t t-if="model_description"> (<t t-esc="model_description"/>)</t>
            </li>
            <li t-if="activity.summary">Summary: <span t-field="activity.summary"/></li>
            <li>Deadline: <span t-field="activity.date_deadline"/></li>
        </ul>
    </p>
</div>
        </template>

        <template id="message_origin_link">
            <p>
                <t t-if="edit">This <t t-esc="self.env['ir.model']._get(self._name).name.lower()"/> has been modified from:</t>
                <t t-else="">This <t t-esc="self.env['ir.model']._get(self._name).name.lower()"/> has been created from:</t>
                <t t-foreach="origin" t-as="o">
                    <a href="#" t-att-data-oe-model="o._name" t-att-data-oe-id="o.id"> <t t-esc="o.display_name"/></a><span t-if="origin.ids[-1:] != o.ids">, </span>
                </t>
            </p>
        </template>
    </data>
</odoo>
=== ./data/neutralize.sql ===
-- deactivate mail template
UPDATE mail_template
   SET mail_server_id = NULL;
-- deactivate fetchmail server
UPDATE fetchmail_server
   SET active = false;
=== ./data/mail_templates_email_layouts.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <template id="mail_notification_layout" name="Mail: mail notification layout template">
<html t-att-lang="lang">
<head>
    <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
</head>
<body style="font-family:Verdana, Arial,sans-serif; color: #454748;">
<t t-set="subtype_internal" t-value="subtype and subtype.internal"/>
<!-- HEADER -->
<t t-call="mail.notification_preview"/>
<div style="max-width: 900px; width: 100%;">
<div t-if="has_button_access" itemscope="itemscope" itemtype="http://schema.org/EmailMessage">
    <div itemprop="potentialAction" itemscope="itemscope" itemtype="http://schema.org/ViewAction">
        <link itemprop="target" t-att-href="button_access['url']"/>
        <link itemprop="url" t-att-href="button_access['url']"/>
        <meta itemprop="name" t-att-content="button_access['title']"/>
    </div>
</div>
<div t-if="subtitles or has_button_access or actions or not is_discussion"
        summary="o_mail_notification" style="padding: 0px;">
    <table role="presentation" cellspacing="0" cellpadding="0" border="0" style="width: 100%; margin-top: 5px;">
        <tbody>
            <tr>
                <td valign="center">
                    <img t-att-src="'/logo.png?company=%s' % (company.id or 0)" style="padding: 0px; margin: 0px; height: auto; max-width: 200px; max-height: 36px;" t-att-alt="'%s' % company.name"/>
                </td>
            </tr>
            <tr>
                <td valign="center">
                    <hr width="100%" style="background-color:rgb(204,204,204);border:medium none;clear:both;display:block;font-size:0px;min-height:1px;line-height:0; margin: 10px 0px;"/>
                </td>
            </tr>
            <tr>
                <td valign="center" style="white-space:nowrap;">
                    <table cellspacing="0" cellpadding="0" border="0">
                        <tbody>
                            <tr>
                                <td t-if="has_button_access" t-att-style="'border-radius: 3px; text-align: center; background: ' + (company.secondary_color if company.secondary_color else '#875A7B')">
                                    <a t-att-href="button_access['url']" style="font-size: 12px; color: #FFFFFF; display: block; padding: 8px 12px 11px; text-decoration: none !important; font-weight: 400;">
                                        <t t-out="button_access['title']"/>
                                    </a>
                                </td>
                                <td t-if="has_button_access">&amp;nbsp;&amp;nbsp;</td>

                                <td t-if="subtitles" style="font-size: 12px;">
                                     <t t-foreach="subtitles" t-as="subtitle">
                                        <span t-attf-style="{{ 'font-weight:bold;' if subtitle_first else '' }}"
                                              t-out="subtitle"/>
                                        <br t-if="not subtitle_last"/>
                                    </t>
                                </td>
                                <td t-else=""><span style="font-weight:bold;" t-out="record_name"/><br/></td>
                                <td>&amp;nbsp;&amp;nbsp;</td>

                                <td t-if="actions">
                                    <t t-foreach="actions" t-as="action">
                                        |
                                        <a t-att-href="action['url']" style="font-size: 12px; color: #875A7B; text-decoration:none !important;">
                                            <t t-out="action['title']"/>
                                        </a>
                                    </t>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </td>
            </tr>
            <tr>
                <td valign="center">
                    <hr width="100%"
                        style="background-color:rgb(204,204,204);border:medium none;clear:both;display:block;font-size:0px;min-height:1px;line-height:0;margin: 10px 0px;"/>
                    <p t-if="subtype_internal" style="background-color: #f2dede; padding: 5px; margin-bottom: 16px; font-size: 13px;">
                        <strong>Internal communication</strong>: Replying will post an internal note. Followers won't receive any email notification.
                    </p>
                </td>
            </tr>
        </tbody>
    </table>
</div>
<!-- CONTENT -->
<div t-out="message.body" style="font-size: 13px;"/>
<ul t-if="tracking_values">
    <t t-foreach="tracking_values" t-as="tracking">
        <li><t t-out="tracking[0]"/>: <t t-out="tracking[1]"/> &#8594; <t t-out="tracking[2]"/></li>
    </t>
</ul>
<t class="o_signature">
    <div t-if="email_add_signature and not is_html_empty(signature)" t-out="signature" style="font-size: 13px;"/>
</t>
<!-- FOOTER -->
<div style="margin-top:32px;">
    <hr width="100%" style="background-color:rgb(204,204,204);border:medium none;clear:both;display:block;font-size:0px;min-height:1px;line-height:0; margin: 16px 0px 4px 0px;"/>
    <b t-out="company.name" style="font-size:11px;"/><br/>
    <p style="color: #999999; margin-top:2px; font-size:11px;">
        <t t-out="company.phone"/>
        <t t-if="company.email and company.phone"> |</t>
        <a t-if="company.email" t-att-href="'mailto:%s' % company.email" style="text-decoration:none; color: #999999;" t-out="company.email"/>
        <t t-if="company.website and (company.phone or company.email)"> |</t>
        <a t-if="company.website" t-att-href="'%s' % company.website" style="text-decoration:none; color: #999999;" t-out="company.website"/>
    </p>
</div>
<p style="color: #555555; font-size:11px;">
    Powered by <a target="_blank" href="https://www.odoo.com?utm_source=db&amp;utm_medium=email" style="color: #875A7B;">Odoo</a>
</p>
</div>
</body></html>
        </template>

        <template id="mail_notification_light">
<html t-att-lang="lang">
<head>
    <meta http-equiv="Content-Type" content="text/html charset=UTF-8" />
</head>
<body>
<t t-set="subtype_internal" t-value="False"/>
<t t-call="mail.notification_preview"/>
<table role="presentation" border="0" cellpadding="0" cellspacing="0" style="padding-top: 16px; background-color: #F1F1F1; font-family:Verdana, Arial,sans-serif; color: #454748; width: 100%; border-collapse:separate;"><tr><td align="center">
<table role="presentation" border="0" cellpadding="0" cellspacing="0" width="590" style="padding: 24px; background-color: white; color: #454748; border-collapse:separate;">
<tbody>
    <!-- HEADER -->
    <tr>
        <td align="center" style="min-width: 590px;">
            <table role="presentation" border="0" cellpadding="0" cellspacing="0" width="100%" style="background-color: white; padding: 0; border-collapse:separate;">
                <tr><td valign="middle">
                    <span style="font-size: 10px;">Your <t t-out="model_description or 'document'"/></span>
                    <br/>
                    <t t-if="has_button_access">
                        <a t-att-href="button_access['url']">
                            <span style="font-size: 20px; font-weight: bold;">
                                <t t-out="message.record_name and message.record_name.replace('/','-') or ''"/>
                            </span>
                        </a>
                    </t>
                    <t t-else="">
                        <span style="font-size: 20px; font-weight: bold;">
                            <t t-out="message.record_name and message.record_name.replace('/','-') or ''"/>
                        </span>
                    </t>
                </td><td valign="middle" align="right">
                    <img t-att-src="'/logo.png?company=%s' % (company.id or 0)" style="padding: 0px; margin: 0px; height: 48px;" t-att-alt="'%s' % company.name"/>
                </td></tr>
                <tr><td colspan="2" style="text-align:center;">
                  <hr width="100%" style="background-color:rgb(204,204,204);border:medium none;clear:both;display:block;font-size:0px;min-height:1px;line-height:0; margin:4px 0px 32px 0px;"/>
                </td></tr>
            </table>
        </td>
    </tr>
    <!-- CONTENT -->
    <tr>
        <td style="min-width: 590px;">
            <t t-out="message.body"/>
        </td>
    </tr>
    <!-- FOOTER -->
    <tr>
        <td align="center" style="min-width: 590px; padding: 0 8px 0 8px; font-size:11px;">
            <hr width="100%" style="background-color:rgb(204,204,204);border:medium none;clear:both;display:block;font-size:0px;min-height:1px;line-height:0; margin: 16px 0px 4px 0px;"/>
            <b t-out="company.name"/><br/>
            <div style="color: #999999;">
                <t t-out="company.phone"/>
                <t t-if="company.email and company.phone"> |</t>
                <a t-if="company.email" t-att-href="'mailto:%s' % company.email" style="text-decoration:none; color: #999999;" t-out="company.email"/>
                <t t-if="company.website and (company.phone or company.email)"> |</t>
                <a t-if="company.website" t-att-href="'%s' % company.website" style="text-decoration:none; color: #999999;" t-out="company.website"/>
            </div>
        </td>
    </tr>
</tbody>
</table>
</td></tr>
<!-- POWERED BY -->
<tr><td align="center" style="min-width: 590px;">
        Powered by <a target="_blank" href="https://www.odoo.com?utm_source=db&amp;utm_medium=email" style="color: #875A7B;">Odoo</a>
</td></tr>
</table>
</body>
</html>
        </template>

        <template id="notification_preview">
<div style="display: none; max-height: 0px; overflow: hidden; color:#fff; font-size:0px; line-height:0px">
    <t t-if="tracking_values">
        <t t-out="tracking_values[0][0]"/>: <t t-out="tracking_values[0][1]"/> &#8594; <t t-out="tracking_values[0][2]"/>
        <t t-if="len(tracking_values) > 1"> |...</t>
        <t t-if="message.preview"> | </t>
    </t>
    <t t-if="subtype_internal">Internal communication: </t><t t-out="message.preview"/>
    <!--Trailing whitespace to push back email content so that it doesn't appear in preview. Specific characters to use may change over time -->
    <t t-out="'&#847; &#8203; ' * 140"/>
</div>
        </template>

        <template id="mail_notification_layout_with_responsible_signature"
                  name="Mail: mail notification layout with responsible signature (user_id of the record)"
                  inherit_id="mail.mail_notification_layout" primary="True">
            <xpath expr="//t[hasclass('o_signature')]" position="replace">
                <t class="o_signature">
                    <div t-if="email_add_signature and 'user_id' in record and record.user_id and not record.env.user._is_superuser() and not is_html_empty(record.user_id.sudo().signature)"
                         t-out="record.user_id.sudo().signature" style="font-size: 13px;"/>
                </t>
            </xpath>
        </template>
    </data>
</odoo>
=== ./data/mail_templates_mailgateway.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <template id="message_notification_limit_email">
            <p>Dear Sender,</p>
            <p>
                The message below could not be accepted by the address <t t-esc="email"/> because you have
                contacted it too many times in the last few minutes.
                <br/>
                Please try again later.
            </p>
            <p>Kind Regards</p>
        </template>

        <template id="mail_bounce_catchall">
<div>
    <p>Hello <t t-esc="message['email_from']"/>,</p>
    <p>The email sent to <t t-esc="message['to']"/> cannot be processed. This address
    is used to collect replies and should not be used to directly contact <t t-esc="res_company.name"/>.</p>
    <p>Please contact us instead using <a t-att-href="'mailto:%s' % res_company.email"><t t-esc="res_company.email"/></a></p>
    <p>Regards,</p>
    <p>The <t t-esc="res_company.name"/> team.</p>
</div>
<blockquote><t t-esc="message['body']"/></blockquote>
        </template>

        <!-- Mail bounce alias mail template -->
        <template id="mail_bounce_alias_security">
<div><t t-out="body"/></div>
<blockquote><t t-out="message['body']"/></blockquote>
        </template>
    </data>
</odoo>
=== ./data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record forcecreate="True" id="ir_cron_mail_scheduler_action" model="ir.cron">
            <field name="name">Mail: Email Queue Manager</field>
            <field name="model_id" ref="model_mail_mail"/>
            <field name="state">code</field>
            <field name="code">model.process_email_queue()</field>
            <field name="user_id" ref="base.user_root"/>
            <field name="interval_number">1</field>
            <field name="interval_type">hours</field>
            <field name="numbercall">-1</field>
            <field eval="False" name="doall"/>
        </record>

        <record id="ir_cron_module_update_notification" model="ir.cron">
            <field name="name">Publisher: Update Notification</field>
            <field name="model_id" ref="model_publisher_warranty_contract"/>
            <field name="state">code</field>
            <field name="code">model.update_notification(None)</field>
            <field name="user_id" ref="base.user_root" />
            <field name="interval_number">1</field>
            <field name="interval_type">weeks</field>
            <field name="numbercall">-1</field>
            <field name="nextcall" eval="(DateTime.now() + timedelta(days=7)).strftime('%Y-%m-%d %H:%M:%S')" />
            <field eval="False" name="doall" />
            <field name="priority">1000</field>
        </record>

        <record id="base.ir_cron_act" model="ir.actions.act_window">
            <field name="domain" eval="[('id','!=', ref('mail.ir_cron_module_update_notification'))]"/>
        </record>

        <record id="ir_cron_delete_notification" model="ir.cron">
            <field name="name">Notification: Delete Notifications older than 6 Month</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="model_id" ref="model_mail_notification"/>
            <field name="code">model._gc_notifications(max_age_days=180)</field>
            <field name="state">code</field>
        </record>

        <record id="ir_cron_mail_gateway_action" model="ir.cron">
            <field name="name">Mail: Fetchmail Service</field>
            <field name="model_id" ref="model_fetchmail_server"/>
            <field name="state">code</field>
            <field name="code">model._fetch_mails()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <!-- Active flag is set on fetchmail_server.create/write -->
            <field name="active" eval="False"/>
        </record>

        <record id="ir_cron_send_scheduled_message" model="ir.cron">
            <field name="name">Notification: Send scheduled message notifications</field>
            <field name="interval_number">1</field>
            <field name="interval_type">hours</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="model_id" ref="model_mail_message_schedule"/>
            <field name="code">model._send_notifications_cron()</field>
            <field name="state">code</field>
        </record>
    </data>
</odoo>
=== ./data/res_partner_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo><data noupdate="1">

    <record id="base.partner_root" model="res.partner">
        <field name="name">OdooBot</field>
        <field name="image_1920" type="base64" file="mail/static/src/img/odoobot.png"/>
    </record>

    <!-- user root should not receive emails at creation -->
    <record id="base.user_root" model="res.users">
        <field name="notification_type">inbox</field>
    </record>

</data></odoo>
=== ./data/mail_groups.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
<data noupdate="1">
    <record id="group_mail_template_editor" model="res.groups">
        <field name="name">Mail Template Editor</field>
        <field name="category_id" ref="base.module_category_hidden"/>
    </record>

    <record id="base.group_system" model="res.groups">
        <field name="implied_ids" eval="[(4, ref('mail.group_mail_template_editor'))]"/>
    </record>

    <!-- By default, allow all users to edit mail templates -->
    <record id="base.group_user" model="res.groups">
        <field name="implied_ids" eval="[(4, ref('mail.group_mail_template_editor'))]"/>
    </record>
</data>
</odoo>
=== ./data/mail_message_subtype_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo><data noupdate="1">

    <!-- Discussion subtype for messaging / Chatter -->
    <record id="mt_comment" model="mail.message.subtype">
        <field name="name">Discussions</field>
        <field name="sequence" eval="0"/>
        <field name="track_recipients" eval="True"/>
    </record>
    <record id="mt_note" model="mail.message.subtype">
        <field name="name">Note</field>
        <field name="default" eval="False"/>
        <field name="internal" eval="True"/>
        <field name="sequence" eval="100"/>
        <field name="track_recipients" eval="True"/>
    </record>
    <record id="mt_activities" model="mail.message.subtype">
        <field name="name">Activities</field>
        <field name="default" eval="False"/>
        <field name="internal" eval="True"/>
        <field name="sequence" eval="90"/>
    </record>

</data></odoo>
=== ./data/mail_channel_demo.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <!-- Discussion groups, done in 2 steps to remove creator from followers -->
        <record model="mail.channel" id="channel_1">
            <field name="name">sales</field>
            <field name="description">Discussion about best sales practices and deals.</field>
        </record>
        <record model="mail.channel" id="channel_2">
            <field name="name">board-meetings</field>
            <field name="description">Board meetings, budgets, strategic plans</field>
        </record>
        <record model="mail.channel" id="channel_3">
            <field name="name">rd</field>
            <field name="description">Research and development discussion group</field>
        </record>

        <!-- Best sales practices messages -->
        <record id="mail_message_channel_1_1" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="mail.channel_1"/>
            <field name="body"><![CDATA[<p>Selling a training session and selling the products after the training session is more efficient than directly selling a pack with the training session and the products.</p>]]></field>
            <field name="message_type">comment</field>
            <field name="subtype_id" ref="mt_comment"/>
            <field name="author_id" ref="base.partner_demo"/>
            <field name="date" eval="(DateTime.today() - timedelta(days=5)).strftime('%Y-%m-%d %H:%M')"/>
        </record>
        <record id="mail_message_channel_1_2" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="mail.channel_1"/>
            <field name="body"><![CDATA[<p>I noted I can not manage efficiently my pipeline when I have more than 50 opportunities in the qualification stage.</p><p>Any advice on this? How do you organize your activities with more than 50 opportunities?</p>]]></field>
            <field name="message_type">comment</field>
            <field name="subtype_id" ref="mt_comment"/>
            <field name="author_id" ref="base.partner_root"/>
            <field name="date" eval="(DateTime.today() - timedelta(days=4)).strftime('%Y-%m-%d %H:%M')"/>
        </record>
        <record id="mail_message_channel_1_2_1" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="mail.channel_1"/>
            <field name="body"><![CDATA[<p>When I have too much opportunities in the pipe, I start communicating with prospects more by email than phonecalls.</p><p>I send an email to create a sense of emergency, like <i>"can I call you this week about our quote?"</i> and I call only those that answer this email.</p><p>You can use the email template feature of Odoo to automate email composition.</p>]]></field>
            <field name="message_type">comment</field>
            <field name="parent_id" ref="mail_message_channel_1_2"/>
            <field name="subtype_id" ref="mt_comment"/>
            <field name="author_id" ref="base.partner_demo"/>
            <field name="date" eval="(DateTime.today() - timedelta(days=3)).strftime('%Y-%m-%d %H:%M')"/>
        </record>

        <!-- Pushed to all employees -->
        <record id="mail_message_channel_whole_1" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="mail.channel_all_employees"/>
            <field name="body"><![CDATA[
<p>
    Great news!<br/>
    Our company has received the Deloitte Fast 50 award.  We are the fastest
    growing company of the country, with a growth of 1549% over the past 5
    years. You can get more information <a href="http://www.openerp.com/node/1244/2012/10">on our blog</a>.
</p>
]]></field>
            <field name="message_type">comment</field>
            <field name="author_id" ref="base.partner_demo"/>
            <field name="date" eval="(DateTime.today() - timedelta(minutes=22)).strftime('%Y-%m-%d %H:%M')"/>
            <field name="subtype_id" ref="mail.mt_comment"/>
        </record>
        <record id="mail_message_channel_whole_2" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="mail.channel_all_employees"/>
            <field name="body"><![CDATA[<p>Your monthly meal vouchers arrived. You can get them at the HR's office.</p>
<p>This month you also get 250 EUR of eco-vouchers if you have been in the company for more than a year.</p>]]></field>
            <field name="message_type">comment</field>
            <field name="author_id" ref="base.partner_demo"/>
            <field name="date" eval="(DateTime.today() - timedelta(hours=1)).strftime('%Y-%m-%d %H:%M')"/>
            <field name="subtype_id" ref="mail.mt_comment"/>
        </record>
        <record id="mail_message_channel_whole_2_1" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="channel_all_employees"/>
            <field name="body"><![CDATA[<p>Thanks! Could you please remind me where is Christine's office, if I may ask? I'm new here!</p>]]></field>
            <field name="parent_id" ref="mail_message_channel_whole_2"/>
            <field name="message_type">comment</field>
            <field name="author_id" ref="base.partner_root"/>
            <field name="date" eval="(DateTime.today() - timedelta(minutes=34)).strftime('%Y-%m-%d %H:%M')"/>
            <field name="subtype_id" ref="mail.mt_comment"/>
        </record>
        <record id="mail_message_channel_whole_2_2" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="channel_all_employees"/>
            <field name="body"><![CDATA[<p>Building B3, second floor to the right :-).</p>]]></field>
            <field name="parent_id" ref="mail_message_channel_whole_2_1"/>
            <field name="message_type">comment</field>
            <field name="author_id" ref="base.partner_demo"/>
            <field name="date" eval="(DateTime.today() - timedelta(minutes=22)).strftime('%Y-%m-%d %H:%M')"/>
            <field name="subtype_id" ref="mail.mt_comment"/>
        </record>

        <!-- Board messages -->
        <record id="mail_message_channel_2_1" model="mail.message">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="mail.channel_2"/>
            <field name="body"><![CDATA[
<p>
    Dear Board Members,
</p>
<p>
    The main events of the month of October are:
</p>
<p>
    <b>Sales:</b>
</p>
<ul>
    <li>Invoicing is respectively of 442k€ for our European company (66% of the budget) and $404k for the U.S. office (75% of the budget). Despite these numbers that are far below our initial expectations, the growth of the month of October is 51% compared to last year.</li>
    <li>The month of September having been better than our initial forecasts, the consolidated yearly revenue is only of $20k below our forecast made during the board of September.</li>
    <li>The consolidated forecast for the end of the year is $6.749k, which is a growth of 76% compared to last year and an achievement of 87% of the budget.</li>
    <li>The recruitment of new resellers has been very good, especially in Europe, where we signed 30 new resellers this month.</li>
</ul>
<p>
    <b>Finance :</b>
</p>
<ul>
    <li>The profit and loss has been negatively impacted this month by revenues that are far beyond the budget and charges that are 15% above the budget. The main extra we had in our charges this month is due to the provisioning of the salaries for the holidays period, $50k.</li>
    <li>We also got the payment of our long awaited subsidies, the cash level has increased of 300K€ which gives a current balance of 963 K€ without including the straight loan of 350 K€.</li>
    <li>The aged customer balance has been similar to the one of the last month with a small decrease of the DSO. We have recruited a new accountant assistant for the credit collection. She is mostly doing phone calls for all invoices that are due since 30 days, so we should get improvements of the DSO in November. The sum of the invoicing on which we have a risk in the aged customer balance is 100K€.</li>
</ul>
<p>
    <b>Resellers and Customers:</b>
</p>
<ul>
    <li>The total number of resellers is 429, across 87 countries.</li>
    <li>The total number of installations of our software increased to 37K, against 33K for the month of September but we still did not reached the highest level we reached during this year (44K in march and may)</li>
    <li>We have passed the 10000th customer in production with 10271 customers at the end of October. The paying customer ratio is 6,6%.</li>
</ul>
<p>
    <b>Launch of the new release:</b>
</p>
<p>
    We are working actively on the new release which is scheduled for the end of November.
</p>
<ul>
    <li>We will publish the release note this week</li>
    <li>The whole Sales Team will be trained on the new version this Friday</li>
    <li>We will do a public announce to our resellers the 21th of November. We plan to show them: a description of the new features, the new distribution strategy, the new pricing and the communication plan.</li>
</ul>
<br/>
<p>
    Nicolas, can you book a meeting room for our meeting of Friday 2pm?
</p>
<p>
    Regards.
</p>
]]></field>
            <field name="message_type">comment</field>
            <field name="subtype_id" ref="mt_comment"/>
            <field name="author_id" ref="base.partner_demo"/>
            <field name="date" eval="(DateTime.today() - timedelta(days=3)).strftime('%Y-%m-%d %H:%M')"/>
        </record>

    </data>
</odoo>
=== ./data/mail_channel_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <record model="mail.channel" id="channel_all_employees">
            <field name="name">general</field>
            <field name="description">General announcements for all employees.</field>
        </record>

        <!-- notify all employees of module installation -->
        <record model="mail.message" id="module_install_notification">
            <field name="model">mail.channel</field>
            <field name="res_id" ref="mail.channel_all_employees"/>
            <field name="message_type">email</field>
            <field name="subtype_id" ref="mail.mt_comment"/>
            <field name="subject">Welcome to Odoo!</field>
            <field name="body"><![CDATA[<p>Welcome to the #general channel.</p>
            <p>This channel is accessible to all users to <b>easily share company information</b>.</p>]]></field>
        </record>

        <record model="mail.channel.member" id="channel_member_general_channel_for_admin">
            <field name="partner_id" ref="base.partner_admin"/>
            <field name="channel_id" ref="mail.channel_all_employees"/>
            <field name="fetched_message_id" ref="mail.module_install_notification"/>
            <field name="seen_message_id" ref="mail.module_install_notification"/>
        </record>

        <record model="mail.channel" id="mail.channel_all_employees">
            <field name="group_ids" eval="[Command.link(ref('base.group_user'))]"/>
        </record>
    </data>
</odoo>
=== ./data/mail_activity_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="mail_activity_data_email" model="mail.activity.type">
            <field name="name">Email</field>
            <field name="icon">fa-envelope</field>
            <field name="sequence">3</field>
        </record>
        <record id="mail_activity_data_call" model="mail.activity.type">
            <field name="name">Call</field>
            <field name="icon">fa-phone</field>
            <field name="category">phonecall</field>
            <field name="delay_count">2</field>
            <field name="sequence">6</field>
        </record>
        <record id="mail_activity_data_meeting" model="mail.activity.type">
            <field name="name">Meeting</field>
            <field name="icon">fa-users</field>
            <field name="sequence">9</field>
        </record>
        <record id="mail_activity_data_todo" model="mail.activity.type">
            <field name="name">To Do</field>
            <field name="icon">fa-tasks</field>
            <field name="delay_count">5</field>
            <field name="sequence">12</field>
        </record>
        <record id="mail_activity_data_upload_document" model="mail.activity.type">
            <field name="name">Upload Document</field>
            <field name="icon">fa-upload</field>
            <field name="delay_count">5</field>
            <field name="sequence">25</field>
            <field name="category">upload_file</field>
        </record>
        <record id="mail_activity_data_warning" model="mail.activity.type">
            <field name="name">Exception</field>
            <field name="icon">fa-warning</field>
            <field name="delay_count">0</field>
            <field name="sequence">99</field>
            <field name="decoration_type">warning</field>
            <field name="active">False</field>
        </record>
    </data>
</odoo>
odoo@5cfc0603deef:~/odoo/addons/mail$ find ./controllers -type f -exec echo "=== {} ===" \; -exec cat {} \;
=== ./controllers/__init__.py ===
# -*- coding: utf-8 -*
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from . import bus
from . import discuss
from . import home
from . import mail
=== ./controllers/bus.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import SUPERUSER_ID, tools
from odoo.http import request, route
from odoo.addons.bus.controllers.main import BusController


class MailChatController(BusController):

    def _default_request_uid(self):
        """ For Anonymous people, they receive the access right of SUPERUSER_ID since they have NO access (auth=none)
            !!! Each time a method from this controller is call, there is a check if the user (who can be anonymous and Sudo access)
            can access to the resource.
        """
        return request.session.uid and request.session.uid or SUPERUSER_ID

    # --------------------------
    # Anonymous routes (Common Methods)
    # --------------------------
    @route('/mail/chat_post', type="json", auth="public", cors="*")
    def mail_chat_post(self, uuid, message_content, **kwargs):
        mail_channel = request.env["mail.channel"].sudo().search([('uuid', '=', uuid)], limit=1)
        if not mail_channel:
            return False

        # find the author from the user session
        if request.session.uid:
            author = request.env['res.users'].sudo().browse(request.session.uid).partner_id
            author_id = author.id
            email_from = author.email_formatted
        else:  # If Public User, use catchall email from company
            author_id = False
            email_from = mail_channel.anonymous_name or mail_channel.create_uid.company_id.catchall_formatted
        # post a message without adding followers to the channel. email_from=False avoid to get author from email data
        body = tools.plaintext2html(message_content)
        message = mail_channel.with_context(mail_create_nosubscribe=True).message_post(
            author_id=author_id,
            email_from=email_from,
            body=body,
            message_type='comment',
            subtype_xmlid='mail.mt_comment'
        )
        return message.id if message else False

    @route(['/mail/chat_history'], type="json", auth="public", cors="*")
    def mail_chat_history(self, uuid, last_id=False, limit=20):
        channel = request.env["mail.channel"].sudo().search([('uuid', '=', uuid)], limit=1)
        if not channel:
            return []
        else:
            return channel._channel_fetch_message(last_id, limit)
=== ./controllers/mail.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import logging

from werkzeug.urls import url_encode

from odoo import http
from odoo.exceptions import AccessError
from odoo.http import request
from odoo.tools import consteq

_logger = logging.getLogger(__name__)


class MailController(http.Controller):
    _cp_path = '/mail'

    @classmethod
    def _redirect_to_messaging(cls):
        url = '/web#%s' % url_encode({'action': 'mail.action_discuss'})
        return request.redirect(url)

    @classmethod
    def _check_token(cls, token):
        base_link = request.httprequest.path
        params = dict(request.params)
        params.pop('token', '')
        valid_token = request.env['mail.thread']._notify_encode_link(base_link, params)
        return consteq(valid_token, str(token))

    @classmethod
    def _check_token_and_record_or_redirect(cls, model, res_id, token):
        comparison = cls._check_token(token)
        if not comparison:
            _logger.warning('Invalid token in route %s', request.httprequest.url)
            return comparison, None, cls._redirect_to_messaging()
        try:
            record = request.env[model].browse(res_id).exists()
        except Exception:
            record = None
            redirect = cls._redirect_to_messaging()
        else:
            redirect = cls._redirect_to_record(model, res_id)
        return comparison, record, redirect

    @classmethod
    def _redirect_to_record(cls, model, res_id, access_token=None, **kwargs):
        # access_token and kwargs are used in the portal controller override for the Send by email or Share Link
        # to give access to the record to a recipient that has normally no access.
        uid = request.session.uid
        user = request.env['res.users'].sudo().browse(uid)
        cids = []

        # no model / res_id, meaning no possible record -> redirect to login
        if not model or not res_id or model not in request.env:
            return cls._redirect_to_messaging()

        # find the access action using sudo to have the details about the access link
        RecordModel = request.env[model]
        record_sudo = RecordModel.sudo().browse(res_id).exists()
        if not record_sudo:
            # record does not seem to exist -> redirect to login
            return cls._redirect_to_messaging()

        suggested_company = record_sudo._get_mail_redirect_suggested_company()
        # the record has a window redirection: check access rights
        if uid is not None:
            if not RecordModel.with_user(uid).check_access_rights('read', raise_exception=False):
                return cls._redirect_to_messaging()
            try:
                # We need here to extend the "allowed_company_ids" to allow a redirection
                # to any record that the user can access, regardless of currently visible
                # records based on the "currently allowed companies".
                cids_str = request.httprequest.cookies.get('cids', str(user.company_id.id))
                cids = [int(cid) for cid in cids_str.split(',')]
                try:
                    record_sudo.with_user(uid).with_context(allowed_company_ids=cids).check_access_rule('read')
                except AccessError:
                    # In case the allowed_company_ids from the cookies (i.e. the last user configuration
                    # on their browser) is not sufficient to avoid an ir.rule access error, try to following
                    # heuristic:
                    # - Guess the supposed necessary company to access the record via the method
                    #   _get_mail_redirect_suggested_company
                    #   - If no company, then redirect to the messaging
                    #   - Merge the suggested company with the companies on the cookie
                    # - Make a new access test if it succeeds, redirect to the record. Otherwise, 
                    #   redirect to the messaging.
                    if not suggested_company:
                        raise AccessError('')
                    cids = cids + [suggested_company.id]
                    record_sudo.with_user(uid).with_context(allowed_company_ids=cids).check_access_rule('read')
            except AccessError:
                return cls._redirect_to_messaging()
            else:
                record_action = record_sudo._get_access_action(access_uid=uid)
        else:
            record_action = record_sudo._get_access_action()
            if suggested_company:
                cids = [suggested_company.id]
            if record_action['type'] == 'ir.actions.act_url' and record_action.get('target_type') != 'public':
                url_params = {
                    'model': model,
                    'id': res_id,
                    'active_id': res_id,
                    'action': record_action.get('id'),
                }
                if cids:
                    url_params['cids'] = cids[0]
                view_id = record_sudo.get_formview_id()
                if view_id:
                    url_params['view_id'] = view_id
                url = '/web/login?redirect=#%s' % url_encode(url_params)
                return request.redirect(url)

        record_action.pop('target_type', None)
        # the record has an URL redirection: use it directly
        if record_action['type'] == 'ir.actions.act_url':
            return request.redirect(record_action['url'])
        # other choice: act_window (no support of anything else currently)
        elif not record_action['type'] == 'ir.actions.act_window':
            return cls._redirect_to_messaging()

        url_params = {
            'model': model,
            'id': res_id,
            'active_id': res_id,
            'action': record_action.get('id'),
        }
        view_id = record_sudo.get_formview_id()
        if view_id:
            url_params['view_id'] = view_id

        if cids:
            url_params['cids'] = ','.join([str(cid) for cid in cids])
        url = '/web?#%s' % url_encode(url_params)
        return request.redirect(url)

    @http.route('/mail/view', type='http', auth='public')
    def mail_action_view(self, model=None, res_id=None, access_token=None, **kwargs):
        """ Generic access point from notification emails. The heuristic to
            choose where to redirect the user is the following :

         - find a public URL
         - if none found
          - users with a read access are redirected to the document
          - users without read access are redirected to the Messaging
          - not logged users are redirected to the login page

            models that have an access_token may apply variations on this.
        """
        # ==============================================================================================
        # This block of code disappeared on saas-11.3 to be reintroduced by TBE.
        # This is needed because after a migration from an older version to saas-11.3, the link
        # received by mail with a message_id no longer work.
        # So this block of code is needed to guarantee the backward compatibility of those links.
        if kwargs.get('message_id'):
            try:
                message = request.env['mail.message'].sudo().browse(int(kwargs['message_id'])).exists()
            except:
                message = request.env['mail.message']
            if message:
                model, res_id = message.model, message.res_id
        # ==============================================================================================

        if res_id and isinstance(res_id, str):
            try:
                res_id = int(res_id)
            except ValueError:
                res_id = False
        return self._redirect_to_record(model, res_id, access_token, **kwargs)
=== ./controllers/discuss.py ===
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from collections import defaultdict
from datetime import datetime, timedelta
from psycopg2 import IntegrityError
from psycopg2.errorcodes import UNIQUE_VIOLATION

from odoo import http
from odoo.exceptions import AccessError, UserError
from odoo.http import request
from odoo.tools import consteq, file_open
from odoo.tools.misc import get_lang
from odoo.tools.translate import _
from werkzeug.exceptions import NotFound


class DiscussController(http.Controller):

    # --------------------------------------------------------------------------
    # Public Pages
    # --------------------------------------------------------------------------

    @http.route([
        '/chat/<string:create_token>',
        '/chat/<string:create_token>/<string:channel_name>',
    ], methods=['GET'], type='http', auth='public')
    def discuss_channel_chat_from_token(self, create_token, channel_name=None, **kwargs):
        return self._response_discuss_channel_from_token(create_token=create_token, channel_name=channel_name)

    @http.route([
        '/meet/<string:create_token>',
        '/meet/<string:create_token>/<string:channel_name>',
    ], methods=['GET'], type='http', auth='public')
    def discuss_channel_meet_from_token(self, create_token, channel_name=None, **kwargs):
        return self._response_discuss_channel_from_token(create_token=create_token, channel_name=channel_name, default_display_mode='video_full_screen')

    @http.route('/chat/<int:channel_id>/<string:invitation_token>', methods=['GET'], type='http', auth='public')
    def discuss_channel_invitation(self, channel_id, invitation_token, **kwargs):
        channel_sudo = request.env['mail.channel'].browse(channel_id).sudo().exists()
        if not channel_sudo or not channel_sudo.uuid or not consteq(channel_sudo.uuid, invitation_token):
            raise NotFound()
        return self._response_discuss_channel_invitation(channel_sudo=channel_sudo)

    @http.route('/discuss/channel/<int:channel_id>', methods=['GET'], type='http', auth='public')
    def discuss_channel(self, channel_id, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        return self._response_discuss_public_channel_template(channel_sudo=channel_member_sudo.channel_id)

    def _response_discuss_channel_from_token(self, create_token, channel_name=None, default_display_mode=False):
        if not request.env['ir.config_parameter'].sudo().get_param('mail.chat_from_token'):
            raise NotFound()
        channel_sudo = request.env['mail.channel'].sudo().search([('uuid', '=', create_token)])
        if not channel_sudo:
            try:
                channel_sudo = channel_sudo.create({
                    'channel_type': 'channel',
                    'default_display_mode': default_display_mode,
                    'group_public_id': None,
                    'name': channel_name or create_token,
                    'uuid': create_token,
                })
            except IntegrityError as e:
                if e.pgcode != UNIQUE_VIOLATION:
                    raise
                # concurrent insert attempt: another request created the channel.
                # commit the current transaction and get the channel.
                request.env.cr.commit()
                channel_sudo = channel_sudo.search([('uuid', '=', create_token)])
        return self._response_discuss_channel_invitation(channel_sudo=channel_sudo, is_channel_token_secret=False)

    def _response_discuss_channel_invitation(self, channel_sudo, is_channel_token_secret=True):
        if channel_sudo.channel_type == 'chat':
            raise NotFound()
        discuss_public_view_data = {
            'isChannelTokenSecret': is_channel_token_secret,
        }
        add_guest_cookie = False
        channel_member_sudo = channel_sudo.env['mail.channel.member']._get_as_sudo_from_request(request=request, channel_id=channel_sudo.id)
        if channel_member_sudo:
            channel_sudo = channel_member_sudo.channel_id  # ensure guest is in context
        else:
            if not channel_sudo.env.user._is_public():
                try:
                    channel_sudo.add_members([channel_sudo.env.user.partner_id.id])
                except UserError:
                    raise NotFound()
            else:
                guest = channel_sudo.env['mail.guest']._get_guest_from_request(request)
                if guest:
                    channel_sudo = channel_sudo.with_context(guest=guest)
                    try:
                        channel_sudo.add_members(guest_ids=[guest.id])
                    except UserError:
                        raise NotFound()
                else:
                    if channel_sudo.group_public_id:
                        raise NotFound()
                    guest = channel_sudo.env['mail.guest'].create({
                        'country_id': channel_sudo.env['res.country'].search([('code', '=', request.geoip.get('country_code'))], limit=1).id,
                        'lang': get_lang(channel_sudo.env).code,
                        'name': _("Guest"),
                        'timezone': channel_sudo.env['mail.guest']._get_timezone_from_request(request),
                    })
                    add_guest_cookie = True
                    discuss_public_view_data.update({
                        'shouldAddGuestAsMemberOnJoin': True,
                        'shouldDisplayWelcomeViewInitially': True,
                    })
                channel_sudo = channel_sudo.with_context(guest=guest)
        response = self._response_discuss_public_channel_template(channel_sudo=channel_sudo, discuss_public_view_data=discuss_public_view_data)
        if add_guest_cookie:
            # Discuss Guest ID: every route in this file will make use of it to authenticate
            # the guest through `_get_as_sudo_from_request` or `_get_as_sudo_from_request_or_raise`.
            expiration_date = datetime.now() + timedelta(days=365)
            response.set_cookie(guest._cookie_name, f"{guest.id}{guest._cookie_separator}{guest.access_token}", httponly=True, expires=expiration_date)
        return response

    def _response_discuss_public_channel_template(self, channel_sudo, discuss_public_view_data=None):
        discuss_public_view_data = discuss_public_view_data or {}
        return request.render('mail.discuss_public_channel_template', {
            'data': {
                'channelData': channel_sudo.channel_info()[0],
                'discussPublicViewData': dict({
                    'channel': [('insert', {'id': channel_sudo.id, 'model': 'mail.channel'})],
                    'shouldDisplayWelcomeViewInitially': channel_sudo.default_display_mode == 'video_full_screen',
                }, **discuss_public_view_data),
            },
            'session_info': channel_sudo.env['ir.http'].session_info(),
        })

    # --------------------------------------------------------------------------
    # Semi-Static Content (GET requests with possible cache)
    # --------------------------------------------------------------------------

    @http.route('/mail/channel/<int:channel_id>/partner/<int:partner_id>/avatar_128', methods=['GET'], type='http', auth='public')
    def mail_channel_partner_avatar_128(self, channel_id, partner_id, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request(request=request, channel_id=channel_id)
        partner_sudo = channel_member_sudo.env['res.partner'].browse(partner_id).exists()
        placeholder = partner_sudo._avatar_get_placeholder_path()
        if channel_member_sudo and channel_member_sudo.env['mail.channel.member'].search([('channel_id', '=', channel_id), ('partner_id', '=', partner_id)], limit=1):
            return request.env['ir.binary']._get_image_stream_from(partner_sudo, field_name='avatar_128', placeholder=placeholder).get_response()
        if request.env.user.share:
            return request.env['ir.binary']._get_placeholder_stream(placeholder).get_response()
        return request.env['ir.binary']._get_image_stream_from(partner_sudo.sudo(False), field_name='avatar_128', placeholder=placeholder).get_response()

    @http.route('/mail/channel/<int:channel_id>/guest/<int:guest_id>/avatar_128', methods=['GET'], type='http', auth='public')
    def mail_channel_guest_avatar_128(self, channel_id, guest_id, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request(request=request, channel_id=channel_id)
        guest_sudo = channel_member_sudo.env['mail.guest'].browse(guest_id).exists()
        placeholder = guest_sudo._avatar_get_placeholder_path()
        if channel_member_sudo and channel_member_sudo.env['mail.channel.member'].search([('channel_id', '=', channel_id), ('guest_id', '=', guest_id)], limit=1):
            return request.env['ir.binary']._get_image_stream_from(guest_sudo, field_name='avatar_128', placeholder=placeholder).get_response()
        if request.env.user.share:
            return request.env['ir.binary']._get_placeholder_stream(placeholder).get_response()
        return request.env['ir.binary']._get_image_stream_from(guest_sudo.sudo(False), field_name='avatar_128', placeholder=placeholder).get_response()

    @http.route('/mail/channel/<int:channel_id>/attachment/<int:attachment_id>', methods=['GET'], type='http', auth='public')
    def mail_channel_attachment(self, channel_id, attachment_id, download=None, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        attachment_sudo = channel_member_sudo.env['ir.attachment'].search([
            ('id', '=', int(attachment_id)),
            ('res_id', '=', int(channel_id)),
            ('res_model', '=', 'mail.channel')
        ], limit=1)
        if not attachment_sudo:
            raise NotFound()
        return request.env['ir.binary']._get_stream_from(attachment_sudo).get_response(as_attachment=download)

    @http.route([
        '/mail/channel/<int:channel_id>/image/<int:attachment_id>',
        '/mail/channel/<int:channel_id>/image/<int:attachment_id>/<int:width>x<int:height>',
    ], methods=['GET'], type='http', auth='public')
    def fetch_image(self, channel_id, attachment_id, width=0, height=0, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        attachment_sudo = channel_member_sudo.env['ir.attachment'].search([
            ('id', '=', int(attachment_id)),
            ('res_id', '=', int(channel_id)),
            ('res_model', '=', 'mail.channel'),
        ], limit=1)

        if not attachment_sudo:
            raise NotFound()

        return request.env['ir.binary']._get_image_stream_from(
            attachment_sudo, width=int(width), height=int(height)
        ).get_response(as_attachment=kwargs.get('download'))

    # --------------------------------------------------------------------------
    # Client Initialization
    # --------------------------------------------------------------------------

    @http.route('/mail/init_messaging', methods=['POST'], type='json', auth='public')
    def mail_init_messaging(self, **kwargs):
        if not request.env.user.sudo()._is_public():
            return request.env.user.sudo(request.env.user.has_group('base.group_portal'))._init_messaging()
        guest = request.env['mail.guest']._get_guest_from_request(request)
        if guest:
            return guest.sudo()._init_messaging()
        raise NotFound()

    @http.route('/mail/load_message_failures', methods=['POST'], type='json', auth='user')
    def mail_load_message_failures(self, **kwargs):
        return request.env.user.partner_id._message_fetch_failed()

    # --------------------------------------------------------------------------
    # Mailbox
    # --------------------------------------------------------------------------

    @http.route('/mail/inbox/messages', methods=['POST'], type='json', auth='user')
    def discuss_inbox_messages(self, max_id=None, min_id=None, limit=30, **kwargs):
        return request.env['mail.message']._message_fetch(domain=[('needaction', '=', True)], max_id=max_id, min_id=min_id, limit=limit).message_format()

    @http.route('/mail/history/messages', methods=['POST'], type='json', auth='user')
    def discuss_history_messages(self, max_id=None, min_id=None, limit=30, **kwargs):
        return request.env['mail.message']._message_fetch(domain=[('needaction', '=', False)], max_id=max_id, min_id=min_id, limit=limit).message_format()

    @http.route('/mail/starred/messages', methods=['POST'], type='json', auth='user')
    def discuss_starred_messages(self, max_id=None, min_id=None, limit=30, **kwargs):
        return request.env['mail.message']._message_fetch(domain=[('starred_partner_ids', 'in', [request.env.user.partner_id.id])], max_id=max_id, min_id=min_id, limit=limit).message_format()

    # --------------------------------------------------------------------------
    # Thread API (channel/chatter common)
    # --------------------------------------------------------------------------

    def _get_allowed_message_post_params(self):
        return {'attachment_ids', 'body', 'message_type', 'partner_ids', 'subtype_xmlid', 'parent_id'}

    @http.route('/mail/message/post', methods=['POST'], type='json', auth='public')
    def mail_message_post(self, thread_model, thread_id, post_data, **kwargs):
        guest = request.env['mail.guest']._get_guest_from_request(request)
        guest.env['ir.attachment'].browse(post_data.get('attachment_ids', []))._check_attachments_access(post_data.get('attachment_tokens'))
        if thread_model == 'mail.channel':
            channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(thread_id))
            thread = channel_member_sudo.channel_id
        else:
            thread = request.env[thread_model].browse(int(thread_id)).exists()
        return thread.message_post(**{key: value for key, value in post_data.items() if key in self._get_allowed_message_post_params()}).message_format()[0]

    @http.route('/mail/message/update_content', methods=['POST'], type='json', auth='public')
    def mail_message_update_content(self, message_id, body, attachment_ids, attachment_tokens=None, **kwargs):
        guest = request.env['mail.guest']._get_guest_from_request(request)
        guest.env['ir.attachment'].browse(attachment_ids)._check_attachments_access(attachment_tokens)
        message_sudo = guest.env['mail.message'].browse(message_id).sudo().exists()
        if not message_sudo.is_current_user_or_guest_author and not guest.env.user._is_admin():
            raise NotFound()
        if not message_sudo.model or not message_sudo.res_id:
            raise NotFound()
        guest.env[message_sudo.model].browse([message_sudo.res_id])._message_update_content(
            message_sudo,
            body,
            attachment_ids=attachment_ids
        )
        return {
            'id': message_sudo.id,
            'body': message_sudo.body,
            'attachments': message_sudo.attachment_ids.sorted()._attachment_format(),
        }

    @http.route('/mail/attachment/upload', methods=['POST'], type='http', auth='public')
    def mail_attachment_upload(self, ufile, thread_id, thread_model, is_pending=False, **kwargs):
        channel_member = request.env['mail.channel.member']
        if thread_model == 'mail.channel':
            channel_member = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(thread_id))
        vals = {
            'name': ufile.filename,
            'raw': ufile.read(),
            'res_id': int(thread_id),
            'res_model': thread_model,
        }
        if is_pending and is_pending != 'false':
            # Add this point, the message related to the uploaded file does
            # not exist yet, so we use those placeholder values instead.
            vals.update({
                'res_id': 0,
                'res_model': 'mail.compose.message',
            })
        if channel_member.env.user.share:
            # Only generate the access token if absolutely necessary (= not for internal user).
            vals['access_token'] = channel_member.env['ir.attachment']._generate_access_token()
        try:
            attachment = channel_member.env['ir.attachment'].create(vals)
            attachment._post_add_create()
            attachmentData = {
                'filename': ufile.filename,
                'id': attachment.id,
                'mimetype': attachment.mimetype,
                'name': attachment.name,
                'size': attachment.file_size
            }
            if attachment.access_token:
                attachmentData['accessToken'] = attachment.access_token
        except AccessError:
            attachmentData = {'error': _("You are not allowed to upload an attachment here.")}
        return request.make_json_response(attachmentData)

    @http.route('/mail/attachment/delete', methods=['POST'], type='json', auth='public')
    def mail_attachment_delete(self, attachment_id, access_token=None, **kwargs):
        attachment_sudo = request.env['ir.attachment'].browse(int(attachment_id)).sudo().exists()
        if not attachment_sudo:
            target = request.env.user.partner_id
            request.env['bus.bus']._sendone(target, 'ir.attachment/delete', {'id': attachment_id})
            return
        if not request.env.user.share:
            # Check through standard access rights/rules for internal users.
            attachment_sudo.sudo(False)._delete_and_notify()
            return
        # For non-internal users 2 cases are supported:
        #   - Either the attachment is linked to a message: verify the request is made by the author of the message (portal user or guest).
        #   - Either a valid access token is given: also verify the message is pending (because unfortunately in portal a token is also provided to guest for viewing others' attachments).
        guest = request.env['mail.guest']._get_guest_from_request(request)
        message_sudo = guest.env['mail.message'].sudo().search([('attachment_ids', 'in', attachment_sudo.ids)], limit=1)
        if message_sudo:
            if not message_sudo.is_current_user_or_guest_author:
                raise NotFound()
        else:
            if not access_token or not attachment_sudo.access_token or not consteq(access_token, attachment_sudo.access_token):
                raise NotFound()
            if attachment_sudo.res_model != 'mail.compose.message' or attachment_sudo.res_id != 0:
                raise NotFound()
        attachment_sudo._delete_and_notify()

    @http.route('/mail/message/add_reaction', methods=['POST'], type='json', auth='public')
    def mail_message_add_reaction(self, message_id, content):
        guest_sudo = request.env['mail.guest']._get_guest_from_request(request).sudo()
        message_sudo = guest_sudo.env['mail.message'].browse(int(message_id)).exists()
        if not message_sudo:
            raise NotFound()
        if request.env.user.sudo()._is_public():
            if not guest_sudo or not message_sudo.model == 'mail.channel' or message_sudo.res_id not in guest_sudo.channel_ids.ids:
                raise NotFound()
            message_sudo._message_add_reaction(content=content)
            guests = [('insert', {'id': guest_sudo.id})]
            partners = []
        else:
            message_sudo.sudo(False)._message_add_reaction(content=content)
            guests = []
            partners = [('insert', {'id': request.env.user.partner_id.id})]
        reactions = message_sudo.env['mail.message.reaction'].search([('message_id', '=', message_sudo.id), ('content', '=', content)])
        return {
            'id': message_sudo.id,
            'messageReactionGroups': [('insert' if len(reactions) > 0 else 'insert-and-unlink', {
                'content': content,
                'count': len(reactions),
                'guests': guests,
                'message': {'id', message_sudo.id},
                'partners': partners,
            })],
        }

    @http.route('/mail/message/remove_reaction', methods=['POST'], type='json', auth='public')
    def mail_message_remove_reaction(self, message_id, content):
        guest_sudo = request.env['mail.guest']._get_guest_from_request(request).sudo()
        message_sudo = guest_sudo.env['mail.message'].browse(int(message_id)).exists()
        if not message_sudo:
            raise NotFound()
        if request.env.user.sudo()._is_public():
            if not guest_sudo or not message_sudo.model == 'mail.channel' or message_sudo.res_id not in guest_sudo.channel_ids.ids:
                raise NotFound()
            message_sudo._message_remove_reaction(content=content)
            guests = [('insert-and-unlink', {'id': guest_sudo.id})]
            partners = []
        else:
            message_sudo.sudo(False)._message_remove_reaction(content=content)
            guests = []
            partners = [('insert-and-unlink', {'id': request.env.user.partner_id.id})]
        reactions = message_sudo.env['mail.message.reaction'].search([('message_id', '=', message_sudo.id), ('content', '=', content)])
        return {
            'id': message_sudo.id,
            'messageReactionGroups': [('insert' if len(reactions) > 0 else 'insert-and-unlink', {
                'content': content,
                'count': len(reactions),
                'guests': guests,
                'message': {'id': message_sudo.id},
                'partners': partners,
            })],
        }

    # --------------------------------------------------------------------------
    # Channel API
    # --------------------------------------------------------------------------

    @http.route('/mail/channel/add_guest_as_member', methods=['POST'], type='json', auth='public')
    def mail_channel_add_guest_as_member(self, channel_id, channel_uuid, **kwargs):
        channel_sudo = request.env['mail.channel'].browse(int(channel_id)).sudo().exists()
        if not channel_sudo or not channel_sudo.uuid or not consteq(channel_sudo.uuid, channel_uuid):
            raise NotFound()
        if channel_sudo.channel_type == 'chat':
            raise NotFound()
        guest = channel_sudo.env['mail.guest']._get_guest_from_request(request)
        # Only guests should take this route.
        if not guest:
            raise NotFound()
        channel_member = channel_sudo.env['mail.channel.member']._get_as_sudo_from_request(request=request, channel_id=channel_id)
        # Do not add the guest to channel members if they are already member.
        if not channel_member:
            channel_sudo = channel_sudo.with_context(guest=guest)
            try:
                channel_sudo.add_members(guest_ids=[guest.id])
            except UserError:
                raise NotFound()

    @http.route('/mail/channel/messages', methods=['POST'], type='json', auth='public')
    def mail_channel_messages(self, channel_id, max_id=None, min_id=None, limit=30, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        messages = channel_member_sudo.env['mail.message']._message_fetch(domain=[
            ('res_id', '=', channel_id),
            ('model', '=', 'mail.channel'),
            ('message_type', '!=', 'user_notification'),
        ], max_id=max_id, min_id=min_id, limit=limit)
        if not request.env.user._is_public():
            messages.set_message_done()
        return messages.message_format()

    @http.route('/mail/channel/set_last_seen_message', methods=['POST'], type='json', auth='public')
    def mail_channel_mark_as_seen(self, channel_id, last_message_id, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        return channel_member_sudo.channel_id._channel_seen(int(last_message_id))

    @http.route('/mail/channel/notify_typing', methods=['POST'], type='json', auth='public')
    def mail_channel_notify_typing(self, channel_id, is_typing, **kwargs):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        channel_member_sudo._notify_typing(is_typing)

    @http.route('/mail/channel/ping', methods=['POST'], type='json', auth='public')
    def channel_ping(self, channel_id, rtc_session_id=None, check_rtc_session_ids=None):
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        if rtc_session_id:
            channel_member_sudo.channel_id.rtc_session_ids.filtered_domain([
                ('id', '=', int(rtc_session_id)),
                ('channel_member_id', '=', channel_member_sudo.id),
            ]).write({})  # update write_date
        current_rtc_sessions, outdated_rtc_sessions = channel_member_sudo._rtc_sync_sessions(check_rtc_session_ids=check_rtc_session_ids)
        return {'rtcSessions': [
            ('insert', [rtc_session_sudo._mail_rtc_session_format() for rtc_session_sudo in current_rtc_sessions]),
            ('insert-and-unlink', [{'id': missing_rtc_session_sudo.id} for missing_rtc_session_sudo in outdated_rtc_sessions]),
        ]}

    # --------------------------------------------------------------------------
    # Chatter API
    # --------------------------------------------------------------------------

    @http.route('/mail/thread/data', methods=['POST'], type='json', auth='user')
    def mail_thread_data(self, thread_model, thread_id, request_list, **kwargs):
        thread = request.env[thread_model].with_context(active_test=False).search([('id', '=', thread_id)])
        return thread._get_mail_thread_data(request_list)

    @http.route('/mail/thread/messages', methods=['POST'], type='json', auth='user')
    def mail_thread_messages(self, thread_model, thread_id, max_id=None, min_id=None, limit=30, **kwargs):
        messages = request.env['mail.message']._message_fetch(domain=[
            ('res_id', '=', int(thread_id)),
            ('model', '=', thread_model),
            ('message_type', '!=', 'user_notification'),
        ], max_id=max_id, min_id=min_id, limit=limit)
        if not request.env.user._is_public():
            messages.set_message_done()
        return messages.message_format()

    @http.route('/mail/read_subscription_data', methods=['POST'], type='json', auth='user')
    def read_subscription_data(self, follower_id):
        """ Computes:
            - message_subtype_data: data about document subtypes: which are
                available, which are followed if any """
        request.env['mail.followers'].check_access_rights("read")
        follower = request.env['mail.followers'].sudo().browse(follower_id)
        follower.ensure_one()
        request.env[follower.res_model].check_access_rights("read")
        record = request.env[follower.res_model].browse(follower.res_id)
        record.check_access_rule("read")

        # find current model subtypes, add them to a dictionary
        subtypes = record._mail_get_message_subtypes()

        followed_subtypes_ids = set(follower.subtype_ids.ids)
        subtypes_list = [{
            'name': subtype.name,
            'res_model': subtype.res_model,
            'sequence': subtype.sequence,
            'default': subtype.default,
            'internal': subtype.internal,
            'followed': subtype.id in followed_subtypes_ids,
            'parent_model': subtype.parent_id.res_model,
            'id': subtype.id
        } for subtype in subtypes]
        return sorted(subtypes_list,
                      key=lambda it: (it['parent_model'] or '', it['res_model'] or '', it['internal'], it['sequence']))

    # --------------------------------------------------------------------------
    # RTC API TODO move check logic in routes.
    # --------------------------------------------------------------------------

    @http.route('/mail/rtc/session/notify_call_members', methods=['POST'], type="json", auth="public")
    def session_call_notify(self, peer_notifications):
        """ Sends content to other session of the same channel, only works if the user is the user of that session.
            This is used to send peer to peer information between sessions.

            :param peer_notifications: list of tuple with the following elements:
                - int sender_session_id: id of the session from which the content is sent
                - list target_session_ids: list of the ids of the sessions that should receive the content
                - string content: the content to send to the other sessions
        """
        guest = request.env['mail.guest']._get_guest_from_request(request)
        notifications_by_session = defaultdict(list)
        for sender_session_id, target_session_ids, content in peer_notifications:
            session_sudo = guest.env['mail.channel.rtc.session'].sudo().browse(int(sender_session_id)).exists()
            if not session_sudo or (session_sudo.guest_id and session_sudo.guest_id != guest) or (session_sudo.partner_id and session_sudo.partner_id != request.env.user.partner_id):
                continue
            notifications_by_session[session_sudo].append(([int(sid) for sid in target_session_ids], content))
        for session_sudo, notifications in notifications_by_session.items():
            session_sudo._notify_peers(notifications)

    @http.route('/mail/rtc/session/update_and_broadcast', methods=['POST'], type="json", auth="public")
    def session_update_and_broadcast(self, session_id, values):
        """ Update a RTC session and broadcasts the changes to the members of its channel,
            only works of the user is the user of that session.
            :param int session_id: id of the session to update
            :param dict values: write dict for the fields to update
        """
        if request.env.user._is_public():
            guest = request.env['mail.guest']._get_guest_from_request(request)
            if guest:
                session = guest.env['mail.channel.rtc.session'].sudo().browse(int(session_id)).exists()
                if session and session.guest_id == guest:
                    session._update_and_broadcast(values)
                    return
            return
        session = request.env['mail.channel.rtc.session'].sudo().browse(int(session_id)).exists()
        if session and session.partner_id == request.env.user.partner_id:
            session._update_and_broadcast(values)

    @http.route('/mail/rtc/channel/join_call', methods=['POST'], type="json", auth="public")
    def channel_call_join(self, channel_id, check_rtc_session_ids=None):
        """ Joins the RTC call of a channel if the user is a member of that channel
            :param int channel_id: id of the channel to join
        """
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        return channel_member_sudo._rtc_join_call(check_rtc_session_ids=check_rtc_session_ids)

    @http.route('/mail/rtc/channel/leave_call', methods=['POST'], type="json", auth="public")
    def channel_call_leave(self, channel_id):
        """ Disconnects the current user from a rtc call and clears any invitation sent to that user on this channel
            :param int channel_id: id of the channel from which to disconnect
        """
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        return channel_member_sudo._rtc_leave_call()

    @http.route('/mail/rtc/channel/cancel_call_invitation', methods=['POST'], type="json", auth="public")
    def channel_call_cancel_invitation(self, channel_id, member_ids=None):
        """ Sends invitations to join the RTC call to all connected members of the thread who are not already invited,
            if member_ids is provided, only the specified ids will be invited.

            :param list member_ids: list of member ids to invite
        """
        channel_member_sudo = request.env['mail.channel.member']._get_as_sudo_from_request_or_raise(request=request, channel_id=int(channel_id))
        return channel_member_sudo.channel_id._rtc_cancel_invitations(member_ids=member_ids)

    @http.route('/mail/rtc/audio_worklet_processor', methods=['GET'], type='http', auth='public')
    def audio_worklet_processor(self):
        """ Returns a JS file that declares a WorkletProcessor class in
            a WorkletGlobalScope, which means that it cannot be added to the
            bundles like other assets.
        """
        return request.make_response(
            file_open('mail/static/src/worklets/audio_processor.js', 'rb').read(),
            headers=[
                ('Content-Type', 'application/javascript'),
                ('Cache-Control', 'max-age=%s' % http.STATIC_CACHE),
            ]
        )

    # --------------------------------------------------------------------------
    # Guest API
    # --------------------------------------------------------------------------

    @http.route('/mail/guest/update_name', methods=['POST'], type='json', auth='public')
    def mail_guest_update_name(self, guest_id, name):
        guest = request.env['mail.guest']._get_guest_from_request(request)
        guest_to_rename_sudo = guest.env['mail.guest'].browse(guest_id).sudo().exists()
        if not guest_to_rename_sudo:
            raise NotFound()
        if guest_to_rename_sudo != guest and not request.env.user._is_admin():
            raise NotFound()
        guest_to_rename_sudo._update_name(name)

    # --------------------------------------------------------------------------
    # Link preview API
    # --------------------------------------------------------------------------

    @http.route('/mail/link_preview', methods=['POST'], type='json', auth='public')
    def mail_link_preview(self, message_id):
        if not request.env['mail.link.preview'].sudo()._is_link_preview_enabled():
            return
        guest = request.env['mail.guest']._get_guest_from_request(request)
        message = guest.env['mail.message'].search([('id', '=', int(message_id))])
        if not message:
            return
        if not message.is_current_user_or_guest_author and not guest.env.user._is_admin():
            return
        guest.env['mail.link.preview'].sudo()._create_link_previews(message)

    @http.route('/mail/link_preview/delete', methods=['POST'], type='json', auth='public')
    def mail_link_preview_delete(self, link_preview_id):
        guest = request.env['mail.guest']._get_guest_from_request(request)
        link_preview_sudo = guest.env['mail.link.preview'].sudo().search([('id', '=', int(link_preview_id))])
        if not link_preview_sudo:
            return
        if not link_preview_sudo.message_id.is_current_user_or_guest_author and not guest.env.user._is_admin():
            return
        link_preview_sudo._delete_and_notify()
=== ./controllers/home.py ===
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import ipaddress

from odoo import _, SUPERUSER_ID
from odoo.http import request
from odoo.addons.web.controllers.home import Home as WebHome

def _admin_password_warn(uid):
    """ Admin still has `admin` password, flash a message via chatter.

    Uses a private mail.channel from the system (/ odoobot) to the user, as
    using a more generic mail.thread could send an email which is undesirable

    Uses mail.channel directly because using mail.thread might send an email instead.
    """
    if request.params['password'] != 'admin':
        return
    if ipaddress.ip_address(request.httprequest.remote_addr).is_private:
        return
    env = request.env(user=SUPERUSER_ID, su=True)
    admin = env.ref('base.partner_admin')
    if uid not in admin.user_ids.ids:
        return
    has_demo = bool(env['ir.module.module'].search_count([('demo', '=', True)]))
    if has_demo:
        return

    user = request.env(user=uid)['res.users']
    MailChannel = env(context=user.context_get())['mail.channel']
    MailChannel.browse(MailChannel.channel_get([admin.id])['id'])\
        .message_post(
            body=_("Your password is the default (admin)! If this system is exposed to untrusted users it is important to change it immediately for security reasons. I will keep nagging you about it!"),
            message_type='comment',
            subtype_xmlid='mail.mt_comment'
        )

class Home(WebHome):
    def _login_redirect(self, uid, redirect=None):
        if request.params.get('login_success'):
            _admin_password_warn(uid)

        return super()._login_redirect(uid, redirect)
odoo@5cfc0603deef:~/odoo/addons/mail$
